# 프로그래밍 언어론

## 프로그래밍 언어란

프로그래밍 언어는 컴퓨터에 프로그래머의 의사를 전달하는 방법이며, 동시에 프로그램을 작성하는 형식이다.

프로그래밍 언어는 컴퓨터 구조의 추상화이기도 하다.
변수는 기억장치를, 연산자는 CPU를 추상화한 것이라 할 수 있다.

## 프로그래밍 언어의 구조 및 해석

### 언어구문

컴퓨터 내부에서는 7비트로 구성된 ASCII 코드를 일반적으로 사용한다.
이후 각 국가의 문자코드에 대응한 문제를 해결하기 위해 16비트 유니코드 체계가 도입되었다.

프로그래밍 언어의 어휘구조는 프로그래밍 언어 알파벳 문자로 구성된 어휘토큰이다.

번역기는 어휘분석 단계에서 입력 프로그램의 일련의 문자를 토큰으로 구분하고,
구문분석 단계에서 이를 처리하여 구문구조를 결정한다.

한 개 이상의 어휘 토큰을 가지고 구문적으로 허용된 프로그램의 일부구조를 언어 구성자(식별자)라고 한다.
프로그래밍 언어는 일부 식별자를 미리 정의하여 사용한다.
미리 정의된 식별자 중에서 재정의 할 수 없도록 한 식별자를 예약어(reserved word)라고 한다.

예약어를 사용함으로써 프로그램을 읽기 쉽도록 하고,
컴파일러가 기호 테이블을 짧은 시간에 탐색하도록 해주며, 오류 검색시간을 줄여준다.

#### 문맥 자유 문법과 BNF

```text
<identifier> ::= <letter> | <identifier> <letter> | <identifier> <digit>
<letter> ::= A | B | C | ... | X | Y | Z
<digit> ::= 0 | 1 | 2 | ... 8 | 9
```

- 비단말(nonterminal) 기호: `<foo>`: BNF 규율로 다시 정의될 대상
- 단말(terminal) 기호: `foo`: 각 언어에서 사용하는 알파벳 문자 집합과 예약어
- 메타기호(meta symbol): `::=`, `|`, `<>`: 언어를 표현하기 위해 사용한 특수기호

모든 생성규칙에서 정의될 대상이 하나의 비단말 기호만으로 구성된다면 그 문법을 문맥자유 문법이라고 한다.
즉, 각 비단말기호가 어디에 나타난다 해도 그에 해당되는 오른쪽 선택으로 언제나 대치될 수 있음을 뜻한다.

특수한 문맥에 의존하여 대치되는 문법을 문맥의존 문법이라고 한다.

#### EBNF

BNF 표기법으로 모든 프로그래밍 언어를 표기할 수 있지만 보다 간결하게 표현할 수 있는 EBNF를 사용하기도 한다.
EBNF는 특수한 의미를 갖는 메타 기호를 더 사용하여 반복되는 부분이나 선택적인 부분을 간결하게 표현할 수 있다.

반복되는 부분은 `{ }`를 사용하여 나타낸며, 선택적인 부분은 `[ ]`를 사용하여 나타낸다.

예를 들어 영문자로 시작하고 최고 8개의 문자를 가질 수 있는 식별자를 EBNF로 표기하면 다음과 같다.

```text
<identifier-name> ::= <letter> {<alphanumeric>}70
<alphanumeric> ::= <letter> | <digit>
<letter> ::= A | B | C | ... | X | Y | Z
<digit> ::= 0 | 1 | 2 | ... 8 | 9
```

반복표기뒤의 두 숫자는 최대(7)와 최소(0)을 나타낸다.

메타기호를 단말기호로 나타낼 때의 혼동을 피하기 위해서 `단말기호: '메타기호'`와 같이 사용한다.

#### 구문도표

구문도표에서 다시 정의될 대상은 사각형으로 표시하고,
단말기호는 원이나 타원으로 표시하고, 비단말 기호는 사각형으로 표시한다.
이들의 사이는 지시선으로 연결한다.

#### Parse Tree

한 표현이 주어진 BNF에 의하여 작성될 수 있는지를 확인하기 위해,
대상을 root로 하고 단말노드를 왼쪽에서 오른쪽으로 나열한 것이 검증하고자 하는 표현과 같은 트리이다.

Parse Tree에서 불필요한 비단말기호를 없애면 (추상)구문 트리라 한다.

그러나, 하나의 BNF식이 두 가지 이상의 Parse Tree로 유도되는 경우 모호성을 갖게된다.
모호성을 갖는 경우 문법을 모호함이 없도록 개정하거나 모호성 제거규칙을 기술해야 한다.

dangling else 문제 ...

### 프로그래밍 언어 구현 기법

#### 컴파일 (Compile)

컴파일러는 source 언어(고급/저급언어)로 작성된 프로그램을 입력받아 object 언어(고급/저급언어)로 된
기능이 동등한 프로그램을 출력해주는 언어처리기이다.

그러나 일반적인 의미에서 컴파일러는 고급 프로그래밍 언어로 작성한 프로그램을 실제 컴퓨터의 기계어로 번역하여
동등한 의미의 기계어 프로그램을 만들어 실행시키는 방법을 지칭한다.

- 컴파일러(compiler): 원시언어를 목적언어(일반적으로 준기계어: relocatable form)로 만들어주는 번역기
- 어셈블러(assembler): 원시언어가 어셈블리 언어인 번역기, 어셈블리 명령어 하나당 하나의 기계어 명령으로 단순번역됨
- 링커(linker): relocatable form으로 구성된 여러 개의 프로그램(컴파일된 목적코드와 라이브러리)을 묶어서, 로드모듈이라는 어느정도 실행가능한 하나의 기계어로 번역해주는 번역기
- 로더(loader): 로드 모듈로 된 기계어 프로그램을 실제 실행 가능한 기계어로 번역해서 주 기억장치에 적재함
- 프리프로세서(preprocessor): 원시언어와 목적언어가 모두 고급언어인 번역기

순서: {고급언어 - 컴파일러 - 목적모듈} - 링커(다수의 목적모듈을 연결) - 로드모듈 - 로더 - 기계어

#### 인터프리트 (Interpreted)

인터프리터가 고급언어로 된 프로그램을 입력받아 기계어 수행과 동일한 알고리즘으로
프로그램의 각 문자을 디코딩하고 실행시킴으로써 고급 언어를 시뮬레이션 하는 것

순서: 고급언어 프로그램 - 인터프리터 - 실행 결과

#### 컴파일 기법과 인터프리트 기법의 비교

컴파일러는 프로그램의 각 문장을 입력된 순서대로 한 번씩 처리하여 효율적인 목적 코드를 생성하지만,
인터프리터는 프로그램의 논리적 순서에 따라 문장을 실행하기 때문에 반복 처리되는 부분이 있다.

많은 경우 프로그래밍 언어는 컴파일 기법과 인터프리트 기법을 함께 사용하여 구현된다.
이러한 구현기법을 중간 코드 실행기법이라고 한다.

## 변수, 바인딩, 식, 제어문

### 변수 (variable)

변수란 선언문 또는 묵시적 선언으로 생성되며, 식별자, 자료속성의 집합, 하나 이상의 주소, 자료값
네 가지 요소로 구성되는데, 주소와 자료값의 관계는 변할 수 있다.

### 바인딩 (binding)

이름에 어떤 속성을 연결하는 과정을 바인딩(binding)이라고 한다.

속성이 이름에 연결되고 계산되는 과정이 어느 시점에서 이루어지는가에 따라 바인딩을 분류할 수 있는데,
그 시간을 바인딩 시간(binding time)이라 한다.

#### 바인딩 시간 (binding time)

바인딩 시간에는 크게 정적 바인딩(static binding)과 동적 바인딩(dynamic binding) 개념이 있다.

- 실행시간
  - 바인딩은 대부분 프로그램 실행시간 중에 이루어지는 동적바인딩이다
  - 모듈의 시작시간: 많은 프로그래밍 언어에서 중요한 바인딩이 모듈 프로그램(블록) 실행 시작시간에 발생한다
  - 실행시간의 사용시점: 프로그램을 실행하는 동안 사용시점에서 수시로 발생하는 바인딩이 있다

- 번역시간
  - 컴파일 언어에서는 대부분의 중요한 바인딩이 번역시간(translation time)에 수행된다
  - 컴파일 언어는 대부분 정적 바인딩을 기본으로 한다
  - 번역시간: 컴파일시간, 링크시간, 로드시간으로 구성된다

- 언어 구현시간
  - 프로그래밍 언어의 구성자에 관한 많은 특성을 구체적으로 한정하지 않고 프로그램을 작성할 때에 특성의 일부를 확정하도록 일임하고 있다.

- 언어의 정의시간
  - 프로그래밍 언어에서 허용되는 자료구조, 프로그램 구조 등에 관한 것은 언어 설계시 확정된다
  - 대부분의 언어에서는 언어의 정의시간 바인딩을 많이해서 언어의 구현시간에 일어나는 바인딩을 최소화 한다

### 선언 (declaration)

선언이란 실행 시 사용할 자료의 속성을 컴파일러 등에 알려주는 프로그램 문장으로, 바인딩을 제공하는 중요한 방법이다.

많은 프로그래밍 언어에서 명시적 선언이 없으면 묵시적 선언(default declaration)으로 간주한다.

자료의 속성에는 자료형, 크기, 이름, 생성시기, 소멸시기, 참조하는 첨자등이 있다.

```java
int[] arr = new int[30];
```

이 선언문은 배열 `arr`의 생성과 소멸 시기, 자료형, 원소의 수, 첨자값의 사용범위(0~29), 각 원소의 자료형, 참조할 배열이름 (arr) 등을 한정하는 선언문이다.

프로그래밍 언어에서 선언문은 다음과 같은 목적을 달성한다.

- 주기억장치 사용과 접근방법의 효율성
  - 프로그램 실행동안 변하지 않는 자료구조의 속성을 한정한다
  - 이러한 정보로 컴파일러는 기억장치 안에서 표기와 자료구조에 접근하는 계산을 최적화 할 수 있다

- 주기억장치 구동 효율
  - 선언에 따라 제공되는 자료구조 속성을 알게됨으로써 실행시간동안 보다 효율적인 기억장소 할당기법을 제공
  - 인터프리터 언어에서는 보다 복잡하고 비효율적으로 주기억장치를 사용한다

- Static type checking
  - type specific operation: 주어진 연산자에 대해 피연산자와 연산결과의 자료형이 고정되지 않은 연산
  - mixed operation: 주어진 연산자에 대한 피연산자와 연산결과의 자료형이 고정되지 않은 연산
  - 고급 프로그래밍 언어에서는 대부분 구현시간에 혼합형 연산을 사용할 수 있지만, 컴파일 타임에 목적코드의 타입은 고정된다

### 할당문 (assignment statement)

할당문은 변수의 내용을 변경할 수 있는 연산이며, 프로그램에서 가장 일반적으로 나타나는 연산문이다.

할당문을 위한 연산자는 다양하게 사용된다: `S = T`, `S := T`, `S <- T`, `LET S = T`, `MOVE T TO S`

- 단순 할당문: `<목적지변수> <할당연산자> <식>`
- 다중 목적 변수 할당문: `W, X ,Y = o`
- 조건 목적 변수 할당문: `flag ? n : m = o`
- 복합할당 연산자: `s = s + t`
- 단항할당 연산자: `t = ++s`, `t = s++`
  - 두 개의 단항 연산자가 동일한 피연산자에 적용될 경우 오른쪽부터 적용: `-s++` == `-(s++)`

할당문은 식으로 혹은 다른 식에 포함된 피연산자로 사용될 수 있다.

`while((s= getchar()) != "\n") { ... }`

할당문 양편에 자료형이 서로 다를 때 혼합형 할당문이라고 한다.

두 형이 일치하지 않는 경우에는 묵시적 형 변환의 사용여부가 고려사항이다.
혼합형 할당문을 허용하는 모든 언어에서 묵시적 형 변환은 오른쪽 식이 평가된 후에 일어난다.

### 상수 및 변수 초기화

변하지 않는 값을 갖는 변수의 사용을 지원하기 위해 상수라는 개념이 존재한다.

상수를 나타내는 이름에 실수로 어떤 값을 재할당 하는 경우 컴파일러가 이를 인식할 수 있으므로,
프로그램의 신뢰성이 증가한다.

### 표현식 (expression)

표현식은 하나 이상의 피연산자를 가지고 자료값의 계산을 기술하는 것이다.

식은 상수나 변수 같은 피연산자, 연산자, 그리고 사용가능한 함수호출(function call)로 구성된다.

식 평가는 피연산자 값에 대하여 주어진 연산을 실행함으로써 이루어진다.

한 프로그램에서 사용되는 모든 변수와 관련 있는 값은 program state space 또는 program environment를 형성한다.
이러한 환경을 변화시키지 않고 오직 값만 생성하는 것이 참조 투명성(referential transparency)이다.

그러나 대부분의 프로그래밍 언어에서는 식에 사용된 함수가 변수값을 변경시켜서 환경을 변화시킬 가능성이 존재한다.

식에서 피연산자와 연산자의 결합순서도 중요하다. (언어별로 연산자 우선순위가 다르다)

일반적으로 여러 피연산자가 있는 식의 평가는 피연산자를 평가한 후 연산자를 적용하여 결과를 얻는다.
이러한 방식을 평가의 적용순서(applicative order)라 한다.

그러나 논리 연산자는 하나의 피 연산자 값만을 알고도 그 식의 값을 알 수도 있다.
이를 위해 언어 내부에 단락회로(short circuit) 평가기법을 도입했다.

### 조건문 (conditional statement)

조건문은 조건에 따라 실행되는 부분이 달라질 때 사용하는 문장이다.

널리 사용되는 조건문으로는 `if elseif else`문과 `switch case`문이 있다.

### 반복문 (iteration statement)

반복문은 하나 이상의 문장을 0번 이상 반복하여 실행시키는 문장이다.

함수형 언어에서는 반복을 재귀호출로 수행한다.

- 사용자 지정 반복: 반복 수행을 하려는 일련의 문장을 묶어 의도한 횟수로 반복한다
  - `break`, `exit`: 반복문을 벗어난다
  - `continue`: 작은 반복구간을 가진다 (다시 루프의 처음으로 돌아감)

- 논리제어 반복문: 반복문은 초기 조건검사를 하고 그 결과가 참이면 반복문을 수행한뒤 다시 조건검사를 행한다

- 제어변수 반복문: `for`문과 같이 제어변수를 사용하여 고정된 횟수의 반복을 표시한다

## 자료형

### 자료형과 형 선언

자료형이란 객체(object)의 집합과 이 객체의 실체(instance)를 생성, 작성, 소멸, 수정, 분해 하는 연산의 집합을 말한다.

명령형 프로그래밍 언어에 필수적으로 내장된 자료형으로는 정수형, 실수형, 문자형, 논리형이 있다.

형 시스템이란 자료형을 정의하고 변수를 특정된 자료형으로 선언하는 도구라 할 수 있다.

형 시스템은 신뢰성 증가뿐만 아니라 프로그램을 읽기 쉽게 해준다.

- 강자료형(strongly type): 자료형에 관한 특성이 번역시간에 확정되는 프로그래밍 언어
- 스칼라형(scalar type): 자료형 영역이 단순한 상수값으로만 구성되어 있는 자료형
- 구조형(structured type): 상수값이 아닌 자료의 집합

### 스칼라 타입

모든 언어는 내장된 자료형을 가지고 있다.
이들 자료형에는 수치자료형, 논리형, 문자형이 있으며 주로 단순형이다.

#### 수치형

수치형은 스칼라형으로 정수 또는 실수의 근사값을 표현한다.
내장된 수치형은 산술적인 것을 구현할 때 컴퓨터의 하드웨어에 의존한다.

이 방법은 고급 프로그래밍 언어로 기술된 정수와 실수의 연산이 그대로 컴퓨터에 내장된 코드로 변환되므로
연산속도가 매우 빠르지만 고급 언어로 작성된 프로그램을 다른 컴퓨터로 이동시키고자 할때 어려움을 초래한다.

`Q = X + Y / Z` (Q, X는 실수형, Y, Z는 정수형)

- 방법1: `Q = X + REAL(Y / Z)`
- 방법2: `Q = X + REAL(Y) / REAL(Z)`

#### 논리형

논리형 값의 영역은 참과 거짓으로 구성된다.

일반적으로 논리형 자료에 관한 연산으로 다섯가지가 정의되어 있다.

- s and t
- s or t
- not s
- s imp(implies) t
- s equiv(equivalence) t

논리형에서 쟁점은 상수의 표현이다

- `true` / `false`
- 수 값과 혼합연산 허용/불가
- 정의된 열거형 `[FALSE, TRUE]`
- 값이 0이 아닌 비트 (`true`) / 값이 0 (`false`)
- ...

#### 문자형

C언어에서는 문자형 `char`가 존재하지만 모든 정수형 변수가 문자를 표현하는데 사용될 수 있다.
C에서 문자열은 문자배열이다.

Java도 C언어의 개념을 가져와 원칙적으로는 같지만, 16비트의 유니코드를 원칙으로 하며 정수형과 형변환이 가능하다.

### 열거형 (enumeration type)

열거형의 영역은 리스트로 정해주며, 연산은 동등 및 순서 관계와 할당연산을 허용한다.

열거형을 정의하는 쉬운 방법으로 프로그래밍 언어는 새로운 자료형을 정의하고 선언할 수 있는 기법과
그 선언된 변수가 취할 수 있는 리터럴 값을 선언하는 기법을 제공해야 한다.

### 배열 (array)

프로그래밍 언어에서는 여러 자료를 묶어서 하나의 단위로 처리할 수 있는 구조형으로 배열(array)과 레코드(record)를 제공하고 있다.

배열은 이름, 차원, 원소형, 첨자집합의 형과 범위등으로 특정 짓는다.

배열의 특정 원소는 두 가지 수준의 구문기법에 의해 참조된다.
하나는 집합체의 이름이고, 다른 하나는 인덱스로 알려진 한 개 이상의 항목으로 구성된 선택자이다.

선택 연산은 배열이름과 인덱스값의 집합에서 집합체의 한 원소에 대응되는 사상(mapping)으로 간주된다.

전형적인 배열의 인덱스 집합은 연속적인 정수집합을 사용하지만 반드시 정수형으로 제한되지는 않는다.
인덱스 집합이 정수형인 경우 차원별로 하한(lb)과 상한(ub) 경계값을 언급하여 인덱스를 정의할 수 있다.

경계값은 `lb <= ub`를 만족시켜야 하며, 그 크기는 `ub - lb + 1` 이다.

배열 변수에 허용되는 인덱스의 바인딩은 보통 정적이지만, 인덱스값 영역이 때로는 동적 바인딩 된다.
정적 배열(static array)은 인덱스 범위가 정적으로 바인딩되고 기억장소 할당이 정적으로 이루어지는 배열이다.

컴퓨터의 기억장소는 일반적으로 1차원 구조이기 때문에 기억시키려는 배열을 연속적인 메모리에 기억시키는 것이 보통이다.
배열의 각 원소는 기억장소의 적당한 위치에 사상하며 이를 구현하기 위해 배열에 관한 정보를 갖는 명세표(descriptor)를 사용한다.

명세표는 배열이름과 원소의 형, 원소의 길이, 배열의 시작주소, 각 차원의 하한과 상한을 포함한다.
원소들은 일반적으로 행 우선(row major)순서로 저장된다. 언어에 따라 열우선(column major)으로 저장되기도 한다.

각 원소들의 위치는 `loc(M(i)) = 시작주소 - 차원하한 * size + i * size`로 구할 수 있으며 마지막항목 `i`만 실행시간에 변화하는 값이다.

### 연상배열 (associative array)

연상배열은 키(key) 값에 의해 접근되는 순서를 갖지 않는 데이터 원소의 집합체이다.
연상배열이 아닌경우 인덱스가 저장될 필요가 없으나, 연상배열에서는 사용자-정의 키가 배열에 함께 저장되어야 한다.

연상배열에 관한 설계 고려사항은 원소의 참조형 식과 연상배열 크기의 바인딩 시간이다.

일반적인 사용사례로 해시 테이블을 들 수 있다.
원소의 탐색이 요구될 때 배열보다 훨씬 효율적이다. 반면 리스트의 모든 원소를 처리할 경우에는 배열을 사용하는 것이 효율적이다.

### 레코드 (record)

레코드형은 이질적 자료로 구성된 조직적 자료형이다.

레코드형의 선언부는 어러 필드와 그들의 값에 대한 형을 기술한다.

```c
struct people =
{
  char name[30];
  double tall[200];
  double weight;
  int age[100];
}
people newpeople, num;
```

위의 선언은 다섯 개의 구성요소로 이루어진 people을 정의한다.
첫 번째 필드 name은 문자열의 배열, tall과 age 필드는 숫자형 배열, weight는 실수형이다.

변수 newpeople과 num은 people형을 갖는 변수로 선언되었다.

레코드와 각 필드를 참조하는 문제는 모든 언어가 동일한 방법을 제공하지는 않는다.

### 포인터 자료형

포인터(pointer)란 어떤 객체에 대한 기억장치 주소참조를 말한다.
포인터 변수(pointer variable)란 객체를 참조하는 기억장치 주소값으로 취하는 식별자이다.

모든 객체에 각각의 명시적인 이름을 제공하지 않고 많은 항목을 동적으로 연결하여 사용하기 위해 포인터 개념이 생겨났다.

객체가 동적으로 할당되는 기억장소 영역을 힙(heap)이라 한다.
힙에 할당되는 변수를 힙 변수라 하며 이러한 변수는 식별자 없이 포인터나 참조형 변수에 의해 참조될 수 있다.
이와같이 이름없는 변수를 무명변수(anonymous variable)라고 한다.

프로그래밍 언어는 자료항목 간에 다중관계(multiple relationship)를 선언할 필요성이 존재한다.
포인터는 하나의 자료가 많은 리스트에 동시에 연결되는 것을 혀용한다.

포인터는 형 연산자를 사용하여 정의하지만, 배열과 레코드와는 달리 구조형이 아니며 스칼라형도 아니다.
포인터는 자료를 저장하는 것이 아니라 다른 객체를 참조하는데 사용하기 때문이다.

포인터형을 제공하는 언어는 기본적인 포인터 연산(할당과 역참조) 두 가지를 제공한다.

#### 참조형

C++에서는 참조형이라 불리는 포인터형을 제공한다.
참조형 변수는 묵시적으로 항상 역참조되는 상수포인터이다.

Java에서 참조변수는 C++ 형태에서 포인터를 대체할 수 잇는 형태로 확장된다.
C++ 포인터와 Java 참조변수 간의 근본적인 차이는,
C++ 포인터는 메모리 주소를 참조하는 반면, Java 참조변수는 클래스 인스턴스를 참조한다는 것이다.

### 자료형 변환

자료형에 대한 정적 형 검사(static type checking)는 번역시간에 수행되며
동적 형 검사(dynamic type checking)는 실행시간에 수행된다.

수식을 기술할 때 프로그래머는 혼합형 연산(generic operation)의 사용을 원하지만
컴파일러는 형 고정 연산을 제공하므로 식에 사용된 자료형의 형 변환(type conversion)이 요구된다.

형 변환은 컴파일러에서 자동으로 수행하는 묵시적 형 변환과 프로그래머가 명시하는 명시적 형변환이 있다.

묵시적 형 변환은 강제로 컴파일러에 요구되어 자동으로 수행되는 자동 형변환 또는 강제변환(coercion)이라하고,
명시적 변환은 프로그래머가 명령문으로 요구한 형 변환으로 캐스트(cast)라 한다.

전형적으로 프로그래밍 언어에서는 스칼라형 사이의 형 변환은 제공되나 구조자료형이나 사용자정의형 사이에서는 형변환이 허용되지 않는다.

## 영역과 수명

### 블록과 영역

복합문(compound statement)은 begin-end를 사용하여 일련의 문장집합을 하나의 단위문장으로 표시하는 형태이다.

복합문 안에 변수, 부프로그램, 레이블과 같은 지역 식별자(local identifier)를 선언하고,
그 묶인 부분만이 복합문의 영역이 되며 이를 블록(block)이라고 한다.

블록은 내부에서 식별자를 선언하여 새로운 프로그램 환경을 설정할 수 있는 특별한 언어구조를 제공한다.
C, C++, Java역시 복합문(두개의 curly brace)에서 선언문을 사용할 수 있다.

번역 시간에 `int x`와 같은 선언문을 만나면 번수이름과 속성이 바인딩된다.
이 정보는 번역이 진행되는 동안 기호 테이블(symbol table)에 저장된다.
실행시간에 선언문이 있는 블록이 활성화되면 기억장소를 할당받는다.

변수는 블록이 실행되는 동안에만 의미 있는 값을 지니며 프로그램 수행제어가 블록을 벗어나면
할당되었던 기억장소가 회수되어 다시 접근할 수 없게 된다.

프로그래밍 언어들은 식별자의 영역이 번역 시에 결정되는 정적 영역 규칙을 따르는 언어와
실행시간에 영역이 결정되는 동적 영역 규칙을 따르는 언어로 구별할 수 있다.

### 정적 영역과 동적 영역

일반적으로 컴파일러 언어는 정적 영역 규칙을 따르는 언어이다.

정적 내포관계를 유지하는 블록 구조 언어에서 블록에서 선언된 변수와 형식 매개변수는 지역(local)변수이며,
그 블록을 내포하고 있는 외부 블록에서 선언된 변수는 비지역(non-local) 또는 전역(global)변수이다.

블록에서 사용되나 해당 블록에서 정의되지 않은 변수들은 자유변수(free variable)로 간주된다.

C 언어는 모든 자유변수에 대하여 현 블록을 내포하고 있는 가장 안쪽의 바깥쪽 블록을 조사하고,
그 블록에도 해당 이름이 선언되어 있지 않으면, 또 다음 바깥쪽의 블록을 조사하는 작업을 반복한다.

자유변수의 선언을 찾는다면 번역시 프로그램 문장만 조사하여 변수의 정의 상태를 결정할 수 있으므로 정적(statc)이라 한다.

만약 비지역 선언이 지역선언 때문에 보이지 않을 때 영역구멍(hole-in-scope)을 가진다고 한다.
따라서 영역과 선언의 가시성은 약간의 차이가 있다.

자유변수의 정의를 해결하는 또 다른 방법이 있다.
식별자 영역을 작성된 프로그램 문맥으로 해결하지 않고 프로그램이 실행되고 있는 순서를 가지고 해결하는 방법이 있는데,
이를 동적 영역 규칙이라고 한다.

```text
procedure Main Is
  X: Integer;
  procedure Sub1 is
    X: Integer;
    begin
      ...
    end
  procedure Sub2 is
    begin
      ...
    end
  begin
    ... -- Main
  end
```

정적 영역 규칙 적용

프로시저 Sub2에서 X 를 사용하면 프로시저 Sub2에는 X가 선언되어 있지 않기 때문에 바로 바깥쪽 프로시저 Main의 X를 참조한다

동적 영역 규칙 적용

프로시저 Sub2에서 X를 사용한다면 참조하는 위치는 프로시저 Sub2를 호출한 순서에 영향을 받는다.
프로시저 Main에서 Sub2를 바로 호출했다면 프로시저 Main의 X를 참조하지만
프로시저 Main에서 프로시저 Sub1을 호출하고 계속해서 프로시저 Sub1에서 프로시저 Sub2를 호출했다면
프로시저 Sub2에서 참조하는 X는 가장 최근에 호출된 Sub1의 X이다.

### 언어에서의 영역

C, C++, Java는 앞에서 기술한 바와 같이 Algol과 같은 블록중심의 언어이며,
begin-end 대신 중괄호(`{ }`)를 사용하여 영역을 정의한다.

C에서는 어느 블록에도 속하지 않고 모든 함수 전체를 영역으로 하는 외부영역(external scope)이 존재한다.

C++와 Java에서는 변수 정의가 함수의 어느 부분에서도 나타날 수 있다.
변수 정의가 함수의 시작부 이외에 나타나면 그 변수의 영역은 정의문부터 함수의 끝까지 이다.

블록 구조를 통한 영역의 개념은 변수를 사용할 프로그램 문장 근처에서 선언하도록 하기 때문에
프로그램의 지역성(locality)을 높여주며, 프로그램 문장과 변수의 지역성은 프로그램의 효율적 수행에 도움이 된다.

### 변수의 생애주기

변수의 생애주기(lifetime)이란 변수가 값을 저장하기 위해 기억장소를 할당받고 있는 시간을 의미한다.

C에서는 변수의 속성으로 자동할당, 정적할당, 프로그래머 지정할당 등을 이용하여 기억장소 할당의 형태를 정한다.

- 자동할당 방식에서 변수의 수명은 그 변수가 포함된 블록의 범위가 같다
- 정적 할당 방식은 프로그램 시작 시 기억장소가 할당되며 블록이 끝나더라도 기억장소 값이 그대로 유지되며 프로그램 종료시 회수된다
- 프로그래머 지정 할당 방식은 프로그램 수행 도죽 `malloc()` 함수를 이용하여 기억장소를 할당하고 `free()`함수를 호출하여 기억장소를 회수할 때까지 기억장소가 유지된다

실행시간 동안 각 블록은 하나의 새로운 환경(environment)을 갖는데,
환경이란 지역 단위로 묶여진 장소와 관련된 모든 식별자를 정의한 용어로서 지역변수, 진입점과 비지역변수에 접근하기 위한 정보도 포함한다.
또한 환경은 그 블록에서 선언된 프로시저와 레이블도 포함한다.

대부분의 언어에서 수명의 또 다른 형태를 볼 수 있는데,
이 언어들은 프로그래머에게 기억장소의 수명 제어권을 부어햐는 것으로서 동적 수명(dynamic extent)이라고 한다.

Java나 C++ 객체는 `new` 연산에 의해 동적으로 생성될 수 있다.
이 기억장소는 레코드가 생성된 블록을 벗어나도 프로그램에 의해 기억장소로부터 해제될 때까지 계속 존재한다.

동적 수명이 프로그래밍 언어에서 사용될 때 기억장소를 회수하는 방법 몇 가지가 있다.

- 기억장소를 실행시간 내내 할당하다가 주프로그램 종료 시 회수
- 기억장소가 다시 사용될 수 있도록 할당된 기억장소를 해제하는 명시적 명령어 제공
- 프로그램에서 더 이상의 참조가 없더라도 계속 기억장소에 존재하게 하다가 새 기억장소가 요구될 때 이들 기억장소를 회수하여 재생
  - 해당 방식을 garbage collection 방식이라 부름
  - 프로그래머가 기억장소 관리에 대해 걱정할 필요가 없음
  - 기억장소의 재생시간이 많이 필요하고, 예측 가능하지 않은 재생이 발생한다

### C의 영역

C는 기본적으로 파일범위, 함수범위, 블록범위의 세가지 영역단위가 있다.

파일범위는 하나의 C 소스 파일 전체를 뜻하는 것이고, 함수범위는 함수가 선언되고 함수가 정의되는 부분을 의미한다.
블록 단위는 일반적으로 중괄호(`{ }`)로 묶인 모든 영역의 범위를 의미한다.

## 기억장소 할당

### 정적 및 동적 기억장소 할당

배열에 할당된 기억장소의 크기나 위치 등이 정적으로 결정(번역시간에 확정)되는 경우, 배열에 대한 접근 코드를 효율적으로 작성할 수 있다.

정적 기억장소 할당을 가능하게 하려면 언어 설계에서 사용된 모든 배열은 확정된 고정 크기로 선언되어야한다.
또한, 부프로그램은 재귀호출이 허용되지 않아야 어떤 부프로그램에 대해서도 부프로그램이 요구하는 크기의 기억장소만 필요하다.

인터프리터 언어는 동적 기억장소 할당이 필요하다. 동적 기억장소 할당은 스택을 사용한다.

### 단위 프로그램

한 프로그램을 여러 단위 프로그램(모듈 프로그램 또는 블록)으로 구성할 수 있다

- 지역변수(local variable): 단위 프로그램이나 블록에서 선언하여 사용하는 변수

- 활성화 상태(activated state): 한 단위 프로그램의 실행 시작부터 종료까지

- 단위 활성화(unit activation): 실행시간에 한 단위 프로그램이 표현된 상태
  - 코드부(code segment): 프로그램의 명령어로 구성된 코드부는 고정 크기로 프로그램 실행동안 내용이 변하지 않는다
  - 활성화 레코드(activation record): 단위 활성화의 지역변수와 관련된 자료를 비롯한 프로그램 실행에 필요한 모든 정보를 가지고 있으며 프로그램의 실행에 따라 내용이 변한다

- 활성화 참조환경(referencing environment): 단위 프로그램에서 선언된 지역변수와 사용가능한 비지역변수로 구성됨

지역변수에 대한 기억장소는 자신의 활성화 레코드에 할당되어 있으며,
비지역변수에 대한 기억장소는 다른 단위 프로그램의 활성화 레코드에 자리잡고 있다.

재귀호출이 허용되는 언어에서 단위 프로그램은 재귀적으로 활성화될 수 있다.
따라서 코드부는 실행시간 내내 하나만 존재하고, 그에 대응하는 활성화 레코드는 단위 프로그램이 활성화될 때마다 새로 생성되므로
코드부와 활성화 레코드의 바인딩이 동적으로 이루어진다.

### 정적 기억장소 할당

번역시간에 크기가 고정되며 번역 시간에 할당되는 변수를 정적 변수라 한다.

각 단위 프로그램에서 지역변수에 필요한 기억장소의 총합은 번역시간에 결정되며 실행시간에는 변하지 않는다.
각 단위 프로그램을 별도로 번역할 수도 있으며, 활성화 레코드는 실행전에 할당하여 실행이 종료될 때까지 유지된다.

변수는 실행시간 전에 생성되어 프로그램 실행시간 전체가 변수의 lifetime이 된다.

단위 프로그램을 컴파일할 때 지역변수는 프로그램에서 발생한 순서대로 단위 활성화 레코드의 연속된 장소를 차지하며 offset으로 대응된다.

번역하는 동안에는 활성화 레코드에 대한 기억장소 위치가 결정되어 있지 않기 때문에 변수에 대한 기억장소 위치가 확정되지 않고 있다가
번역시간 마지막 단계인 프로그램 실행전에 링크되어 적재할 때 기억장소 위치가 확정된다.

정적 기억장소 할당 기법은 쉽게 구현될 수 있지만, 프로그래밍언어에 대한 유연성이 적어진다

- 재귀호출을 허용하지 않는다
- 배열을 비롯한 모든 변수에 대한 기억장소가 정적으로 한정되기 때문에 실행중에 배열의 크기등을 변화시킬 수 없다
- 활성화 되지 않을 수도 있는 활성화 레코드가 주기억장소를 항상 차지함

### 스택 기반 동적 기억장소 할당

프로그램 실행 중에 기억장소를 할당하는 동적 기억장소 할당 기법을 사용하는 언어는 블록 중심언어로,
컴파일 기법을 사용하여 구현되는 언어와 인터프리트 기법을 사용하여 구현되는 언어로 구분된다.

블록 기반 언어란 변수의 영역을 제한하고, 프로그램을 적당한 단위 프로그램으로 나누어 구성할 수 있도록 블록 개념을 도입한 언어이다.

일반적으로 블록 기반 언어에서 단위 프로그램은 블로과 부프로그램 두 가지 범주가 있다.

- 블록: 전체 프로그램 실행과정에서 특정 블록의 실행차례가 되면 활성화되며 지역선언문을 가지는 새로운 실행환경을 정의하는 단위
- 부프로그램: 호출문에 의하여 호출되었을 때 활성화되며, 부프로그램에서 변수영역은 블록에서의 변수영역과 동일한 규칙을 따른다

블록 기반 언어에서도 변수가 필요로 하는 전체 기억장소 용량이 정적으로 결정되거나,
실행 시 단위 프로그램이 활성화되는 시점에서야 비로소 변수가 필요로 하는 기억장소 용량이 결정된다.

#### 활성화 레코드 크기가 정적으로 결정되는 경우

단위 프로그램이 활성화 되는 시점에서 지역변수가 생성되며, 지역변수가 필요로 하는 기억장소 용량이 번역시간에 결정되는 경우이다.
동적 기억장소 할당(`calloc()`, `malloc()`)을 제외한 C언어가 이 부류에 속한다.

활성화 레코드의 크기와 변수에 대한 offset이 번역시간에 결정되더라도 실행시간 단위 프로그램이 활성화되는 시점에서 활성화 레코드의 위치가 결정되므로
변수에 대한 실제 주소는 실행시간에 바인딩되는데, 이러한 종류의 변수를 준정적 변수(semi-static variable)라고한다.

준정적 변수는 다음과 같은 효과를 갖는다

- 재귀호출 가능
- 스택기반의 기억 장소할당을 수행할 수 있어 주기억장소를 효율적으로 사용할 수 있다

호출된 활성화 레코드에서 호출한 활성화 레코드로 반환되려면
활성화 레코드안에 호출한 활성화의 return point와 호출한 활성화 레코드를 가리키는 주소값을 저장할 포인터가 있어야 한다.

- 코드부
  - 활성화레코드
    - 반환주소 (return point)
    - 동적링크 (dynamic link): 포인터
    - 기타 활성화 레코드 (지역변수, 매개변수, 정적링크 등...)

현재 활성화된 활성화 레코드로부터 동적 링크를 추적한 연결을 동적 체인(dynamic chain)이라고 한다.

한 활성화의 실행이 끝나면 그에 대응하는 활성화 레코드는 해당 활성화 레코드를 회수하며
새로운 활성화가 발생하면 해당되는 활성화 레코드를 주기억장소에 새로 할당한다.

따라서 프로그램이 실행되는 동안 동적 기억장소 할당을 요구하는 것은 활성화 레코드뿐이며,
활성화 레코드가 발생했다가 회수되는 순서가 단위 프로그램 호출 실행순서이므로 스택 개념을 갖는다.

#### 단위 프로그램이 활성화되는 시점에서 활성화 레코드의 크기가 결정되는 경우

활성화 레코드의 크기와 활성화 레코드에서 지역변수의 위치가 정적으로 바인딩되지 못하는경우,
단위 프로그램이 활성화되는 시점에서 지역변수가 모두 생성되며, 지역변수가 요구하는 기억장소의 크기가 결정된다.

이러한 종류의 변수를 준동적 변수(semi-dynamic variable)라고 한다.

준동적변수는 준정적변수 개념에 다음 조건이 덧붙여진다.
번역시간에 단위 활성화 레코드에서 지역변수의 offset이 상수값으로 확정되지 못하여 주소에 대한 최종 확정을 실행시간까지 늦춰야 한다.

준동적변수는 활성화 레코드의 크기가 동적으로 바인딩되지만
한 번 바인딩되면 활성화된 프로그램이 종결될 때까지 크기가 변할 수 없는 것이 동적변수와의 차이점이다.

#### 활성화 레코드가 동적으로 변하는 경우

C, C++, Java 등의 언어에서는 프로그래머가 실행 중에 기억장소의 크기를 변화시키는 자료값을 다룰 수 있다.
따라서, 동적변수는 활성화 레코드가 활성화되는 시점에서도 활성화 레코드의 크기를 알 수 없다.

동적변수의 대표적인 예로 유연성 배열(flexible array)가 있다.

동적변수는 생존하는 동안 자료의 크기가 동적으로 변할 수 있는 자료를 의미하기 때문에,
이 자료의 기억장소를 스택으로 할당할 수 없어 힙(heap)이라고 하는 기억장소에 할당한다.

힙에 할당한 후 포인터 변수가 이를 가리키도록 바인딩하면된다.

#### 비지역변수의 참조방법

##### 정적 체인 사용

비지역변수에 접근하기 위한 한 가지 방법으로 모든 활성화 레코드에 정적 링크(static link)라고 불리는 포인터를 할당하고,
그 포인터로 하여금 작성된 프로그램의 정적 내포관계에 있는 활성화 레코드를 가리키게 한다.

비지역변수에 대한 참조는 정적 체인을 따라서 검색해 먼저 발견된 변수를 참조하면 된다.
정적 체인을따라 활성화 레코드를 검색하는 일은 시간이 많이 소요되므로 실제로 사용하지는 않는다.

##### 디스플레이 사용

디스플레이 사용기법은 단위 프로그램의 호출과 반환횟수에 비하여 비지역변수의 사용이 상대적으로 증가할 경우 매력적인 방법이다.

정적 링크 대신에 실행시간 어느 시점에서나 정적 체인관계를 디스플레이라고 부르는 1차원 가변배열을 사용하여 유지한다.

디스플레이를 사용하여 비지역변수를 참조하기는 쉽고 어떤 비지역변수에 대한 참조시간도 동일하지만,
활성화 레코드가 할당되거나 회수될 때마다 디스플레이 내용을 변경하는 일을 수행해야 한다.

따라서 활성화 레코드에 일부 변화한 디스플레이값을 저장하는 기억장소를 요구하게된다.
즉, 활성화 레코드가 새로 할당될 때에는 현재 사용중인 디스플레이를 새로 작성하고,
회수될 때에는 저장된 값을 가지고 디스플레이를 다시 원위치시킨다.
