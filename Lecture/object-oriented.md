# 객체지향 프로그래밍

"객체지향의 사실과 오해"를 읽으면서 요약한 것임

## 협력하는 객체

객체지향에서 가장 중요한 개념 세 가지는 역할, 책임, 협력이다.

애플리케이션의 기능은 더 작은 책임으로 분할되고 책임은 적절한 역할을 수행할 수 있는 객체에 의해 수행된다.
객체는 자신의 책임을 수행하는 도중에 다른 객체에 요청을 하기도 한다.

객체는 충분히 협력적이어야 한다. 다른 객체의 요청에 응답해야 하고, 응답여부를 객체 스스로 판단해야 한다.
또한 객체는 충분히 자율적이어야 한다. 즉 자신의 행동을 스스로 결정하고 책임질 수 있어야 한다.

### 협력과 메시지

객체는 협력을 위해 다른 객체에게 메시지를 전송하고 다른 객체로부터 메시지를 수신한다.
이때 메시지를 전송하는 객체를 송신자(sender)라 하고 메시지를 수신하는 객체를 수신자(receiver)라 한다.

수신자는 메소드(method)를 통해 수신된 메시지를 처리한다.
객체지향 프로그래밍에서 메소드는 클래스 안의 함수 또는 프로시저를 통해 구현된다.

메시지와 메소드의 분리는 객체의 협력에 참여하는 객체들간의 자율성을 증진시킨다.
메시지를 전송한 객체에서는 특정한 행동을 기대하지만 구체적인 방법에 관해서는 관여하지 않는다.

### 자율적인 객체

객체는 상태(state)와 행동(behavior)를 함께 지닌 실체이다.

객체의 자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로부터 출발한다.
객체의 사적인 부분은 객체 스스로 관리하고 외부에서 간섭할 수 없도록 차단해야 하고,
객체의 외부에서는 접근이 허락된 수단을 통해서만 객체와 소통해야 한다.

객체는 다른 객체가 무엇을 수행하는지 알 수 있지만, 어떻게 수행하는지에 대해서는 알 수 없다.

## 객체지향의 객체

객체는 상태(state), 행동(behavior), 식별자(identity)를 지닌 실체이다.

### 상태

객체가 주변 환경과의 상호작용에 어떻게 반응하는가는 그 시점까지 객체에 어떤 일이 발생했느냐에 좌우된다.
즉, 어떤 행동의 결과는 과거에 어떤 행동들이 일어났느냐에 의존한다.

그러나 상태를 이용하면 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 설명할 수 있다.

그 자체로 독립적인 의미를 가지기보다는 다른 객체의 특성을 표현하는데 사용되는 것이 상태이다.
때로는 단순한 값이 아니라 객체를 사용해서 다른 객체의 상태를 표현해야 할 경우도 있다.
그런 경우 객체와 다른 객체가 연결되어 있는지 여부로 표현할 수 있다.

이처럼 객체와 객체 사이의 의미있는 연결을 링크(link)라 한다. 객체의 링크를 통해서만 메시지를 주고 받을 수 있다.
링크는 다른 객체를 참조할 수 있다는 것을 의미하며, 이는 한 객체가 다른 객체의 식별자를 알고 있는 것이다.

**결론적으로 모든 객체의 상태는 단순한 값과 객체의 조합으로 표현할 수 있다.**
이때 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(property)라고 한다.

일반적으로 property는 변경되지 않고 고정된다, 반면 property value는 시간이 흐름에 따라 변경되므로 동적이다.

### 행동

객체의 상태는 저절로 변하지 않는다. 객체의 상태를 바꾸는 것은 객체의 자발적인 행동 뿐이다.

객체의 행동에 의해 객체의 상태가 변경되는 것은 행동이 부수효과(side effect)를 초래한다는 것을 의미한다.
부수효과를 통해 객체의 행동을 상태 변경의 관점으로 기술할 수 있다.

객체의 행동은 객체의 상태를 변경시키지만 행동의 결과는 객체의 상태에 의존적이다.
따라서, 상태와 행동 사이에는 다음과 같은 관계가 있다.

- 객체의 행동은 상태에 영향을 받는다: 상호작용이 현재의 상태에 어떤 방식으로 의존하는가
- 객체의 행동은 상태를 변경시킨다: 상호작용이 어떻게 현재의 상태를 변경시키는가

또한 객체의 행동은 객체가 협력에 참여할 수 있는 방법이다.
객체가 어떤 행동을 하도록 만드는 것은 객체가 외부로부터 수신한 메시지다.

객체는 협력하는 과정에서 자기 자신의 상태뿐만 아니라 다른 객체의 상태변경을 유발할 수도 있다.
따라서 객체의 행동으로 인해 발생하는 결과는 두 가지로 볼 수 있다.

- **객체 자신의 상태 변경**
- **행동 내에서 협력하는 다른 객체에 대한 메시지 전송**

### 식별자

객체란 식별 가능한 경계를 가진 모든 사물이다.
객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 것을 의미한다.

이 프로퍼티를 식별자라고 한다. 모든 객체는 식별자를 가지며 식별자를 이용해 객체를 구별할 수 있다.

반면 단순한 값은 식별자를 가지지 않는다.
값(value)은 숫자, 문자열, 날짜, 시간, 금액 등과 같이 변하지 않는 양을 모델링한다.

흔히 값의 상태는 변하지 않기 때문에 불변상태(immutable state)를 가진다고 한다.
따라서 값의 경우 두 인스턴스의 상태가 같다면 두 인스턴스가 같은 것으로 판단할 수 있다.

이처럼 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 동등성(equality)이라고 한다.

객체는 변경되는 상태를 포함하며, 행동을 통해 상태를 변경한다.
따라서 객체는 가변 상태(mutable state)를 가진다고 할 수 있다.

타입이 같은 두 객체의 상태가 완전히 똑같더라도 두 객체는 독립적인 별개의 객체로 다뤄야 한다.
객체의 경우 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 동일성(identical)이라 한다.

- **객체는 어떤 상태에 있더라도 유일하게 식별가능하다**

### 캡슐화

현실과 객체지향 세계의 차이는, 객체지향에서 모든객체는 자신의 상태를 스스로 관리하는 자율적인 존재란 것이다.

현실에서는 층위가 존재하는 두 객체라도,
객체지향에서는 행동으로 상태변화를 일으키기 위해서 다른 객체에게 메시지를 전송하는 것이 전부이고 수신자의 상태 변경은 알지못한다.

이것이 캡슐화이다.
객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 방법 역시 행동 뿐이다.

상태를 외부에 노출 시키지 않고 행동을 경계로 캡슐화하는 것은 결과적으로 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.

### 행동이 상태를 결정한다

상태를 중심으로 객체를 바라보면 안된다. 상태를 먼저 결정하고 행동을 나중에 결정하는 것은 설계에 나쁜영향을 준다.

- 상태를 먼저결정하면 캡슐화가 저해된다
- 객체를 협력이라는 문맥에서 벗어나게 만든다
- 객체의 재사용성이 저하된다

행동은 객체가 협력에 참여하는 유일한 방법이므로, 상태가 아닌 행동에 초점을 맞춰 객체를 설계해야 한다.

## 타입과 추상화

복잡한 구조 및 세부사항을 이해하기 쉽고 예측 가능한 수준으로 분해하고 단순화 하는 전략이 추상화이다.

- 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만든다
- 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만든다

### 객체지향과 추상화

객체지향의 수많은 객체들을 개별적인 단위로 취급하기에는 너무 방대하다.
따라서 공통적인 특성을 기준으로 개념(concept)을 적용하여 객체를 여러 그룹으로 묶는다.

개념을 이용하여 객체를 여러 그룹으로 분류(classification) 할 수 있다.

결국 각 객체는 특정한 개념을 표현하는 그룹의 일원이다.
개념 그룹의 일원이 된 객체를 그 개념의 인스턴스(instance)라 한다.

- 심볼(symbol): 개념을 가리키는 이름이나 명칭
- 내연(intension): 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지를 확인할 수 있음
- 외연(extension): 개념에 속하는 모든 객체의 집합

### 객체의 분류

분류란 특정한 객체를 특정한 개념의 객체 집합에 포함시키는 작업을 의미한다.

개념을 통해 객체를 분류하는 과정은 추상화의 두 가지 전략을 모두 사용한다.
개념으로 묶은 것은 개별 객체간의 세세한 특성을 배제하고 공통점을 취한 일반화 과정을 적용한 것이다.

### 타입

앞에서 설명한 개념을 컴퓨터공학적 용어로 표현하면 타입(type)이다.

데이터 타입은 메모리안에 저장된 데이터의 종류를 분류하는 데 사용되는 메모리 집합에 관한 메타데이터이다.
데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

객체를 타입에 따라 분류하고 타입에 이름을 붙이는 것은 새로운 데이터 타입을 선언하는 것이다.
그러나 객체는 데이터가 아니다. 객체에서 중요한 것은 객체의 행동이다.

**어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.**
어떤 객체들이 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있다.

**객체의 내부적인 표현은 외부로부터 철저히 감춰져야 한다.**
객체의 행동을 가장 효과적으로 수행할 수 있다면 객체 내부상태를 어떻게 표현하더라도 상관없다.

#### 행동 우선

객체가 다른 객체와 동일한 타입이라면 동일한 행동을 하기만 하면 된다.
객체가 어떤 데이터를 가지고 있는지는 타입 결정과는 아무런 관계가 없다.

여기에서 동일한 행동이란 동일한 책임을 의미하고, 동일한 책임이란 동일한 메시지 수신을 말한다.

다만 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를수 밖에 없다.
이를 통해 동일한 요청에 대해 다른 방식으로 응답하는 다형성을 갖게된다.

**즉, 다형적인 객체들은 동일한 타입 또는 타입계층에 속하게된다.**

**데이터의 내부 표현방식과 무관하게 행동만이 고려대상이라는 사실은 외부에 데이터를 감춰야 함을 의미하는데 이 원칙을 캡슐화라 한다.**

#### 타입의 계층

타입과 타입 사이에는 일반화/특수화 관계가 존재할 수 있다.

- 일반적 타입: 특수한 타입이 가진 모든 행동들 중에서 일부 행동만을 가지는 타입
- 특수한 타입: 일반적인 타입이 가진 모든 타입을 포함하지만 거기에 자신만의 행동을 추가한 타입

일반적인 타입을 슈퍼타입(supertype)이라 하고, 특수한 타입을(subtype)이라 한다.

어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행위적 호환성을 만족해야 한다.
일반적으로 서브타입은 슈퍼타입의 행위와 호환되기 때문에 서브타입은 슈퍼타입을 대체할 수 있어야 한다.

### 정적 모델

타입을 사용하는 이유는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기 위함이다.

객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다.
따라서 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.

클래스는 타입을 구현할 수 있는 여러 방법중 하나이므로 클래스만으로 타입을 구현할 수 있는 것은 아니다.

## 역할 책임 협력

### 협력

이상한나라의 앨리스 예시를 살펴보자

- 누군가가 왕에게 재판을 요청하여 재판시작
- 왕이 하얀 토끼에게 증인을 부를 것을 요청
- 왕의 요청을 받은 토끼는 모자장수에게 증인석으로 입장할 것을 요청
- 모자장수는 증인석에 입장함으로써 토끼의 요청에 응답
- 모자장수의 입장은 왕이 토끼에게 요청했던 증인 호출에 대한 응답이기도 함
- 왕은 모자장수에게 증언할 것을 요청
- 모자장수는 자신이 알고 있는 내용을 증언함으로써 왕의 요청에 응답

어떤 객체가 특정한 요청을 받아들일 수 있는 이유는 요청에 대해 적절한 방식으로 응답하는데 필요한 행동방식을 갖고 있기 때문이다.

요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.

### 책임

어떤 객체가 어떤 요청에 대해 답하거나 적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 할 수 있다.

즉, 객체의 책임은 객체가 무엇을 알고 있는가(knowing)와 무엇을 할 수 있는가(doing)로 구성된다.

- 아는 것
  - 개인적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 계산할 수 있는 것에 대해 아는것

- 하는 것
  - 객체를 생성하거나 계산하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작하는 것
  - 다른 객체의 활동을 제어하고 조절하는 것

책임은 객체의 공용 인터페이스(public interface)를 구성한다.

#### 메시지

객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 메시지 전송(message-send)이라 한다.

주의할 점은 책임과 메시지의 수준이 같지 않다는 점이다.

책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것이다.
책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할 되는 것이 일반적이다.

#### 역할

어떤 객체가 수행하는 책임의 집합은 객체가 협력안에서 수행하는 역할을 나타낸다.
앞의 예시에서 왕은 재판한다는 책임으로 판사, 모자장수는 증인석에 입장한다와 증언한다의 책임으로 증인의 역할을 수행하게 된다.

앞의 예시에 이어 모자장수 다음으로 요리사와 앨리스가 증언을하게된 상황을 살펴보자.
그러면 증언을 하게되는 협력과정이 세 번 반복된다.

세 번의 협력과정은 판사와 증인이라는 역할을 사용하여 하나의 협력으로 추상화 할 수 있다.

- 누군가가 **판사**에게 재판을 요청하여 재판시작
- **판사**가 하얀 토끼에게 증인을 부를 것을 요청
- **판사**의 요청을 받은 토끼는 **증인**에게 증인석으로 입장할 것을 요청
- **증인**은 증인석에 입장함으로써 토끼의 요청에 응답
- **증인**의 입장은 **판사**가 토끼에게 요청했던 증인 호출에 대한 응답이기도 함
- **판사**는 **증인**에게 증언할 것을 요청
- **증인**은 자신이 알고 있는 내용을 증언함으로써 **판사**의 요청에 응답

판사와 증인의 역할을 수행할 수 있는 객체는 역할에 해당하는 책임을 수행할 수 있는 객체이다.

그러나 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다.
왕은 재판을 할 책임 뿐만아니라 국정수행의 책임이있고, 모자장수는 증언을 하는 책임 이외에 모자를 판매할 책임이 있다.

### 객체와 협력

객체의 행위에 초점을 맞추기 위해서는 협력이라는 실행 문맥 안에서 책임을 분배해야 한다.
각 객체가 가져야 하는 상태와 행위에 대해 고민하기 전에 그 객체가 참여할 문맥인 협력을 정의해야 한다.

객체지향 시스템에서 가장 중요한 것은 충분히 자율적인 동시에 충분히 협력적인 객체를 만드는 것이다.

### 객체지향 설계 기법

- 책임 주도 설계
  - 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다
  - 시스템 책임을 더 작은 책임으로 분할한다
  - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다
  - 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
  - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다

- 디자인 패턴
  - 디자인 패턴은 모범이 되는 설계이다
  - 디자인 패턴은 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍이다
  - 디자인 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다

- 테스트 주도 개발
  - 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다
  - 테스트에 필요한 간접 입력 값을 제공하기 위한 stub이나 간접 출력 값을 검증하기 위한 mock을 사용하는 것은 협력에 대한 것을 코드로 표현한 것이다

## 책임과 메시지

### 자율적인 책임

객체지향의 객체들은 자율적 객체로 구성되어 있다.

객체가 책임을 자율적으로 수행하기 위해서는 객체에게 할당되는 책임이 자율적이어야 한다.

그러나 포괄적이고 추상적인 책임을 선택한다고 해서 반드시 좋은 것은 아니다.
책임이 수행방법을 제한할 정도로 구체적인 것도 문제지만 협력의 의도를 명확하게 표현하지 못할정도로 추상적인 것 역시 문제이다.

자율적인 책임의 특징은 객체가 어떻게(how) 해야 하는가가 아니라 무엇(what)을 해야 하는가를 설명한다는 것이다.

### 메시지와 메소드

메시지는 메시지 이름과 인자의 두 부분으로 구성된다.
메시지 전송은 수신자, 메시지 이름, 인자의 조합이 된다.

앞의 예시를 메시지 전송으로 표현하면 다음과 같을 것이다: `모자장수.증언하라(어제, 왕국)`

객체는 메시지를 수신하면 먼저 해당 메시지를 처리할 수 있는지 확인한다.
메시지를 처리할 수 있다면 메시지를 처리할 방법인 메소드를 선택하게 된다.

메시지를 수신한 객체가 실행시간에 메소드를 선택할 수 있다는 사실은
다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분하는 핵심적 특징 중 하나이다.

#### 다형성

다형성이란 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메소드를 이용해 메시지를 처리할 수 있는 메커니즘이다.
따라서 다형성을 하나의 메시지와 하나 이상의 메소드 사이의 관계로 볼 수 있다.

다형성은 역할, 책임, 협력과 관련이 있다.
서로 다른 객체들이 다형성을 만족한다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다.

기본적으로 다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미한다.

즉, 다형성은 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춤으로써 달성된다.

#### 유연하고 확장가능하고 재사용 가능함

송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다

- 협력이 유연해진다
  - 송신자는 수신자가 메시지를 이해한다면 누구든 상관없다 (어떠한 타입의 객체이든)

- 협력이 수행되는 방식을 확장할 수 있다
  - 송신자에게 영향없이 수신자를 교체할 수 있으므로 협력의 세부적인 수행방식을 쉽게 수정할 수 있다

- 협력이 수행되는 방식을 재사용할 수 있다
  - 협력에 영향을 미치지 않고서 다양한 객체들이 수신자의 자리를 대체할 수 있으므로 다양한 문맥에서 협력을 재사용할 수 있다

**메시지**는 송신자와 수신자 사이의 결합도를 낮춤으로써 설계를 유연하고 확장가능하고 재사용 가능하게 만든다
따라서 설계의 품질을 높이기 위해서는 메시지를 잘 선택해야 한다

### 객체지향과 메시지

클래스가 코드를 구현하기 위해 사용할 수 있는 중요한 추상화 도구인 것은 사실이지만
객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지로부터 나온다.

클래스는 단지 동적인 객체들의 특성과 행위를 정적인 텍스트로 표현하기 위해 사용할 수 있는 추상화 도구이다.
클래스를 중심에 두는 설계는 유연하지 못하고 확장하기 어렵다.

객체지향 설계는 어떤 객체가 어떤 메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가를
중심으로 객체 사이의 협력 관계를 구성하는 것이다.

#### What/Who 사이클

What/Who 사이클의 의미는 객체 사이의 협력 관계를 설계하기 위해서는
먼저 어떤 행위(what)를 수행할 것인지를 결정한 후에 누가(who) 그 행위를 수행할 것인지를 결정해야 한다는 것이다.

여기에서 어떤 행위는 메시지이다.

#### (상태를)묻지말고 시켜라

What/Who 사이클에서는 어떤 객체가 필요한지 생각하지 말고 어떤 메시지가 필요한지를 우선 고민한다.
따라서 메시지를 결정하는 시점에서는 송신자는 메시지 수신자 객체의 상태를 알 수 없다.

이를 통해 메시지를 수신할 객체의 캡슐화가 증진되고 송-수신자가 느슨하게 결합된다.

### 객체 인터페이스

#### 인터페이스

인터페이스란 어떤 두 사물이 마주치는 경계 지점에서 서로 상호작용할 수 있게 이어주는 방법이나 장치를 의미한다.

인터페이스는 세상 어느 곳에나 존재한다.
사람들 사이의 소통을 위해서는 말과 글, 스마트폰 조작에서는 손가락, TV시청을 위해서는 리모콘을 사용한다.
운전을 하기위해 자동차와 운전자 사이에는 핸들, 변속기, 엑셀, 브레이크, 계기판 등으로 구성된 인터페이스가 있다.

일반적으로 인터페이스는 다음과 같은 세 가지의 특징을 지닌다

- 인터페이스의 사용법을 익히기만 하면 내부 구조나 동작방식을 몰라도 대상을 조작하거나 의사를 전달할 수 있다
- 인터페이스 자체는 변경하지 않고 내부구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않는다
- 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용 할 수 있다

#### 메시지가 인터페이스를 결정한다

인터페이스는 외부에서 접근 가능한 공개된 인터페이스와 내부에서만 접근할 수 있는 감춰진 인터페이스로 구분된다.

공용 인터페이스건 감춰진 인터페이스건 상관없이 메시지 전송을 통해서만 접근할 수 있다.
다만 메시지 송신자가 다른 객체인지 객체 자신인지만 다를 뿐이다.

결과적으로 객체가 협력에 참여하기 위해 수행하는 메시지가 객체의 공용 인터페이스 모양을 암시한다.

앞서 What/Who 사이클이 적용되면 우선 메시지를 결정하고 메시지를 수행할 객체를 나중에 결정하기 때문에,
메시지가 수신자의 인터페이스를 결정할 수 밖에 없다.

### 인터페이스 구현의 분리

#### 객체 관점에서 생각

객체지향적인 사고방식을 위해서 다음의 원칙이 중요하다

- 좀 더 추상적인 인터페이스: 수신자의 자율성 보장
- 최소 인터페이스: 외부에서 사용할 필요가 없는 인터페이스는 노출하지 않으므로, 객체 수정의 외부 영향을 최소화한다
- 인터페이스와 구현 간의 차이: 객체의 외부는 공용인터페이스, 객체의 내부는 구현(implementation)이다

#### 구현(implementation)

객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 용어는 구현(implementation)이다.
객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함된다.

객체는 상태를 가진다. 상태는 외부에 노출되는 공용 인터페이스는 아니다.

객체는 행동을가진다. 행동은 메소드로 표현되며 메소드를 구성하는 코드 자체는 공용 인터페이스는 아니다.

#### 인터페이스와 구현의 분리 원칙

객체를 설계할 때 객체 외부에 노출되는 인터페이스와 객체 내부에 숨겨지는 구현을 명확하게 분리해야 한다.

인터페이스와 구현의 분리가 중요한 이유는 소프트웨어는 항상 변경되기 때문이다.

수많은 객체들이 연결되어 있는 상황에서 어떤 객체를 수정했을 때 어떤 객체가 영향을 받는지 판단하기는 너무나도 어렵다.
따라서 변경에 대한 안전 지역과 위험지역을 분리하는 것이 필요하다.

#### 인터페이스와 캡슐화

객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것을 캡슐화라고 한다.

객체지향에서 캡슐화는 두 가지 관점에서 사용된다

- 상태와 행위의 캡슐화
  - 객체는 상태와 행동을 하나의 단위로 묶는 자율적인 실체이다
  - 객체는 외부에서 접근해야만 하는 행위만 골라 공용 인터페이스를 통해 노출한다
  - 이 관점에서 캡슐화를 데이터 캡슐화라고 한다

- 사적인 비밀의 캡슐화
  - 외부에서 객체와 의사소통할 수 있는 고정된 경로를 공용 인터페이스라고 한다
  - 외부에 제공해야 할 필요가 있는 메시지만을 객체의 공용 인터페이스에 포함시킨다

## 객체 지도

요구사항은 계속 변하기 때문에 모델이 제공해야 하는 기능 역시 지속적으로 변할 수 밖에 없다.
따라서 기능을 중심으로 구조를 종속시키는 접근방법은 범용적이지 않고 재사용이 불가능하며 변경에 취약하다.

이와 달리 안정적인 구조를 중심으로 기능을 종속시키는 접근법은 범용적이고 재사용가능하며 변경에 유연하게 대처할 수 있는 모델을 만든다.

### 구조 설계 대 기능 설계

구조 측면의 설계는 제품의 형태가 어떠해야 하는지에 초점을 맞춘다.
기능 측명의 설계는 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞춘다.

불행하게도 요구사항은 변경되므로, 미래에 대비하는 가장 좋은 방법은 변경을 수용할 수 있는 선택의 여지를 설계에 마련하는 것이다.

### 구조와 기능

객체지향을 위해서는 사용자에게 제공할 기능과 기능을 담을 안정적인 구조라는 재료가 준비되어 있어야 한다.

- 구조는 사용자나 이해관계자들이 도메인(domain)에 관해 생각하는 개념과 개념들 간의 관계로 표현한다
- 기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현한다

### 구조

사람들은 자신이 관심을 가지고 있는 특정한 분야의 문제를 해결하기 위해 소프트웨어를 사용한다.
사용자가 소프트웨어를 사용하는 대상 분야를 도메인이라고 한다.

#### 도메인 모델

도메인 모델에서 모델은 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태이다.

도메인 모델은 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태이다.

Donald Norman은 제품을 설계할 때 제품에 관한 모든 것이 사용자들이 제품에 대해 가지고 있는 멘탈모델과 일치해야 한다고 주장했다.

- 멘탈 모델: 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 이해하고 현상에 반응하기 위해 구축하는 모형
- 사용자 모델: 사용자가 제품에 대해 가지고 있는 개념들의 모습
- 디자인 모델: 설계자가 마음 속에 갖고 있는 시스템에 대한 개념
- 시스템 이미지: 최종 제품

도메인 모델은 도메인에 대한 사용자 모델, 디자인 모델, 시스템 이미지를 포괄하도록 추상화한 소프트웨어 모델이다.
따라서 도메인 모델은 소프트웨어에 대한 멘탈 모델이다.

#### 표현적 차이

소프트웨어 객체는 현실 객체를 모방한 것이 아니라 은유를 기반으로 재창조 한 것이다.
따라서 소프트웨어 객체는 현실 객체가 갖지 못한 특성을 가질 수도 있고 현실 객체가 하지 못하는 행동을 할 수도 있다.

이처럼 소프트웨어 객체와 현실 객체 사이의 의미적 거리를 가리켜 표현적 차이라고 한다.

소프트웨어 객체는 그 대상이 현실적인지의 여부와 관계없이 도메인 모델을 통해 표현되는 도메인 객체들을 은유해야 한다.

도메인 모델을 기반으로 설계하고 구현하는 것은 사용자가 도메인을 바라보는 관점을 그대로 코드에 반영할 수 있게 한다.
결과적으로 표현적 차이는 줄어들 것이며, 사용자의 멘탈 모델이 그대로 코드에 반영될 수 있을 것이다.

#### 도메인 모델의 구조적 안정성

도메인 모델의 핵심은 사용자가 도메인을 바라보는 관점을 반영해 소프트웨어를 설계하고 구현하는 것이다.
도메인에 대한 사용자의 관점을 반영해야 하는 이유는 사용자들이 누구보다도 도메인의 본질적인 측면을 잘 이해하고 있기 때문이다.

사용자 모델에 포함된 개념과 규칙은 비교적 변경될 확률이 적기 때문에 사용자 모델을 기반으로 설계와 코드를 만들면 변경에 대처할 가능성이 커진다.

### 기능

#### 유스케이스

기능적 요구사항이란 시스템이 사용자에게 제공해야 하는 기능의 목록을 정리한 것이다.
정확한 기능적 요구를 얻기 위해서는 목표를 가진 사용자와 사용자의 목표를 만족시키기 위해 일련의 절차를 수행하는 시스템간의 상호작용 관점에서 시스템을 바라봐야 한다.

사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 유스케이스라 한다.

유스케이스의 가치는 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기 형식으로 묶을 수 있다는 점이다.

> 사용자 목표가 유스케이스의 핷미이다. 유스케이스는 공통의 사용자 목표를 통해 강하게 연관된 시나리오의 집합이다

#### 유스케이스의 특성

- 유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 텍스트이다
  - 유스케이스는 다이어그램이 아니다
  - 유스케이스의 핵심은 사용자와 시스템간의 상호작용을 일련의 이야기 흐름으로 표현하는 것이다

- 유스케이스는 하나의 시나리오가 아니라 여러 시나리오의 집합이다
  - 시나리오는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이야기 또는 경로이다
  - 시나리오를 유스케이스 인스턴스라고도 한다

- 유스케이스는 단순한 feature 목록과 다르다
  - feature는 시스템이 수행해야 하는 기능의 목록의 단순나열이다
  - 유스케이스는 단순히 기능을 나열하는 것이 아니라 이야기를 통해 연관된 기능들을 함께 묶을 수 있다

- 유스케이스는 사용자 인터페이스와 관련된 세부정보를 포함하지 말아야 한다
  - 유스케이스는 자주 변경되는 사용자 인터페이스 요소를 배재하고 사용자관점에서 시스템의 행위에 초점을 맞춘다
  - 사용자 인터페이스를 배제한 유스케이스 형식을 본질적인 유스케이스(essential use case)라 한다

- 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다
  - 유스케이스의 목적은 연관된 시스템의 기능을 이야기 형식으로 모으는 것이지 내부 설계를 설명하는 것이 아니다

유스케이스는 단지 사용자가 바라보는 시스템의 외부 관점만을 표현한다.
유스케이스는 시스템의 내부 구조나 실행 메커니즘에 관한 어떤 정보도 제공하지 않는다.

유스케이스는 단지 기능적 요구사항을 사용자의 목표라는 문맥을 중심으로 묶기 위한 정리기법이다.

유스케이스는 설계 기법도, 객체지향 기법도 아니며 유스케이스를 객체로 변환하는 작업은 정해진 틀 속에서 이루어지는 것이 아니다.

### 구조와 기능의 통합

도메인 모델은 안정적인 구조를 개념화 하기 위해, 유스케이스는 불안정한 기능을 서술하기 위해 가장 일반적으로 사용되는 도구이다.

시스템에 할당된 커다란 책임은 시스템 안의 작은 규모의 객체들이 수행해야 하는 작은 규모의 책임으로 세분화 된다.

작은 규모의 객체들의 선택은 도메인 모델에 포함된 개념을 은유하는 소프트웨어 객체를 선택으로 이루어진다.
협력을 완성하는 데 필요한 메시지를 식별하면서 객체들에게 책임을 할당해 나간다.

마지막으로 협력에 참여하는 객체를 구현하기 위해 클래스를 추가하고 속성과 함께 메소드를 구현하면 시스템의 기능이 완성된 것이다.

#### 이자 계산 기능 구현 예시

유스케이스

1. 예금주가 금일 기준으로 예금을 해지할 경우 지급받을 수 있는 이자 계산을 요청한다
2. 시스템은 중도 해지시 지급받을 수 있는 이자를 계산한 후 결과를 사용자에게 제공한다

시스템에 중도 해지 이자액을 계산하라는 책임이 부여되고, 이 책임은 시스템 안에서 객체들의 협력으로 구현되어야 한다.

도메인 모델을 기반으로 이자 계산이라는 시스템 책임을 아래와 같이 세부 책임으로 분할하고 객체들에게 할당할 수 있다.

- 정기예금
  - 정기예금은 해지일자를 전달받아 이자계산을 시작하는 책임을 맏는다
  - 정기예금은 해당 일자가 약정 기간에 포함되는지 확인한 후 포함될 경우 계좌에게 이자 계산을 요청한다

- 계좌
  - 계좌는 예금액과 해지일자를 이자율에게 전달해서 이자를 계산하게 한다

- 이자율
  - 이자율은 전달받은 예금액과 해지일자를 이용해 이자액을 계산한 후 이자액을 포함하는 이자를 생성하여 반환한다

이자 계산에 필요한 객체와 책임이 식별되었으므로 객체를 클래스로, 책임을 클래스의 메소드로, 도메인 모델의 속성을 클래스의 인스턴스 변수로 변환한다.

#### 연결 완전성

객체지향은 도메인을 모델링하기 위한 기법과 도메인을 프로그래밍하기 위해 사용하는 기법이 동일하다.
따라서 도메인 모델링에서 사용한 객체와 개념을 프로그래밍 설계에서의 객체와 클래스로 매끄럽게 변환할 수 있다.

## 코드와 모델의 연결

개념 관점(Conceptual Perspective) 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.
도메인이란 사용자들이 관심을 가지고 있는 특정 분야나 주제를 말한다.

명세 관점(Specification Perspective)에 이르면 사용자 영역인 도메인을 벗어나 개발자 영역인 소프트웨어로 초점이 옮겨진다.
명세관점은 소프트웨어 내부의 객체들가 협력을 위해 무엇을 할 수 있는가에 초점을 맞춘다.
인테페이스와 구현을 분리하는 것이 객체지향 설계의 기본 원칙임을 기억해야 한다.

구현 관점(Implementation Perspective)은 실제 작업을 수행하는 코드와 연관되어 있다.
구현 관점은 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다.

개념 관점, 명세 관점, 구현 관점은 순차적인 개발과정이 아니다. 동일한 클래스를 다른 방향에서 바라보는 것을 의미한다.

클래스가 은유하는 개념은 도메인 관점을 반영하고, 공용 인터페이스는 명세관점을 바녕하며 속성과 메소드는 구현관점을 반영한다.

### 커피 전문점

#### 도메인

커피 전문점을 객체들로 구성된 작은 세상으로 바라보자

- 커피 전문점에는 메뉴판이 있다
  - 메뉴판은 여러개의 메뉴 항목 객체를 포함하는 객체이다

- 손님은 메뉴판을 바라보고 바리스타에게 원하는 커피를 주문한다
  - 손님 객체는 메뉴판 객체에 있는 메뉴 객체중 하나를 선택해서
  - 바리스타 객체에게 전달한다

- 바리스타는 주문받은 메뉴에 따라 커피를 제조한다
  - 바리스타는 커피를 만드는 자율적인 객체이다
  - 바리스타가 만드는 커피 역시 메뉴판, 메뉴 항목과 구별되는 별개의 객체이다

정리해보면 객체 지향의 관점에서 커피 전문점이라는 도메인은 손님 객체, 매뉴항목 객체, 메뉴판 객체, 바리스타 객체, 커피 객체로 구성되어있다.

객체들간의 포함/합성(containment/composition)관계와 연관(association)관계를 알아보자

- 손님 타입
  - 메뉴판 타입을 알고 있어야 한다 (연관)
  - 바리스타 타입을 알고 있어야 한다 (연관)

- 바리스타 타입
  - 커피 타입을 알고 있어야 한다 (연관)

- 메뉴판 타입
  - 메뉴 항목 타입을 포함한다 (합성)

### 설계

설계하고 있는 협력은 커피를 주문 하는 것이다. 첫 번째 메시지는 `(메뉴이름)커피를 주문하라`이다.

메시지를 찾았으니 메시지를 처리하기에 적합한 객체를 선택해야 한다.
앞에서 커피 전문점을 추상화한 도메인 모델에서 책임을 수행하기 적합한 타입을 찾아야 한다.
적합한 타입을 찾았다면 책임을 수행할 객체를 해당 타입의 인스턴스로 만들어야 한다.

`커피를 주문하라`는 메시지를 처리할 객체는 손님 타입의 인스턴스이다.
손님 객체는 커피를 주문할 책임을 할당 받았다.

손님이 커피를 주문하는 도중에 스스로 할 수 없는 일이 있다면 다른 객체에게 이를 요청해야 한다.

손님은 메뉴항목에 대해 알지 못한다(메뉴항목은 메뉴판의 일부이다).
따라서 손님은 `(메뉴이름)메뉴 항목을 찾아라`라는 메시지를 발생시킨다.

메뉴항목을 찾을 책임은 메뉴판 객체에게 있다.
손님은 메뉴판 객체에게 `메뉴 항목을 찾아라`라는 메시지를 전달하고 메뉴항목을 얻는다.

손님은 얻은 메뉴항목으로 `(메뉴이름)커피를 제조하라`라는 메시지를 발생시킨다.

커피를 제조할 책임은 바리스타에게 있다.
바리스타는 메시지를 받아 자신이 가진 커피제조 기술로 커피를 제조한다.

바리스타는 `커피타입의 (메뉴이름)인스턴스를 생성하라`는 메시지를 발생시키고 생성한 객체를 손님에게 전달한다.

이 과정의 인터페이스를 정리하면 다음과 같다

- 손님 객체
  - 커피를 주문하라

- 메뉴판 객체
  - 메뉴항목을 찾아라: 메뉴항목 객체 반환

- 바리스타 객체
  - 커피를 제조하라: 커피 객체 반환

- 커피객체
  - 생성하라

위의 인터페이스를 클래스로 표현하면 다음과 같을 것이다

```java
class Customer {
    public void order(String menuName) { ... }
}

class MenuItem {
    ...
}

class Menu {
    ...
}

class Barista {
    public Coffee makeCoffee(MenuItem menuItem) { ... }
}

class Coffee {
    // constructor
    public Coffee(MenuItem menuItem) { ... }
}
```

### 구현

클래스에 수행 방법을 메소드로 구현해야 한다

커피주문을 수행하기 위해서는 Customer가 Menu 객체와 Barista 객체에 접근할 수 있어야 한다.
따라서 해당 객체에 대한 참조를 알고 있어야 한다.

```java
class Customer {
    public void order(String menuName, Menu menu, Barista barista) {
        MenuItem = menuItem = menu.choose(menuName);
        Coffee coffee = barista.makeCoffee(menuItem);
        ...
    }
}
```

Menu는 `menuName`에 해당하는 MenuItem을 찾아야 하는 책임이 있다.
이를 위해 Menu가 내부적으로 MenuItem을 관리하고 있어야 한다.

```java
class Menu {
    private List<MenuItem> items;

    public Menu(List<MenuItem> items) {
      this.items = items;
    }

    public MenuItem choose(String name) {
      for (MenuItem item : Items) {
        if (item.getName().equals(name)) {
          return item;
        }
      }
      return null;
    }
}
```

바리스타는 MenuItem을 이용해서 커피를 제조한다

```java
class Barista {
    public Coffee makeCoffee(MenuItem menuItem) {
        Coffee coffee = new Coffee(menuItem);
        return coffee;
    }
}
```

Coffee는 자신을 생성하기 위한 생성자를 제공한다.
Coffee는 커피 이름과 가격을 속성으로 가지고 생성자 안에서 MenuItem에 요청을 보내 커피이름과 가격을 얻은후 속성에 저장한다.

```java
class Coffee {
    private String name;
    private int price;

    // constructor
    public Coffee(MenuItem menuItem) {
        this.name = menuItem.getName();
        this.price = menuItem.cost();
    }
}
```

메뉴항목은 이름과 `getName()`과 `cost()` 메시지에 응답할 수 있는 메소드를 구현해야 한다.

```java
class MenuItem {
    private String name;
    private int price;

    // constructor
    public MenuItem(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public int cost() {
      return price;
    }

    public String getName() {
      return name;
    }
}
```

### 도메인 개념 참조

어떤 메시지가 있을 때 그 메시지를 수신할 객체를 선택하기 위해서는,
도메인 개념 중에서 가장 적절한 것을 선택하는 것이 좋다.

이는 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 한다.

## 추상화 기법

### 추상화

추상화는 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단이다.

다음은 추상화 기법을 나타낸 것이다

- 분류와 인스턴스화
  - 분류: 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정
  - 인스턴스화: 범주로부터 객체를 생성하는 과정

- 일반화와 특수화
  - 일반화: 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다
  - 특수화: 일반화의 역

- 집합과 분해
  - 집합: 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정
  - 분해: 전체를 부분으로 분리하는 집합의 반대과정

### 분류와 인스턴스화

객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다.
개념이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다.

자동차 범주에 적용되는 개념은 '바퀴를 이용해 사람들을 한 장소에서 다른 장소로 운반하는 운송수단'이다.

세상에 존재하는 객체에 개념을 적용하는 과정을 분류라고 한다.

수많은 개별적인 현상들을 객체라 하고 하나의 개념을 타입이라고 한다.
다시 말해 분류는 객체를 타입과 연관시키는 것이다.

분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 인스턴스화라고 한다.

타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요하다

- 심볼: 타입을 가리키는 간략한 이름이나 명칭
- 내연: 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다
- 외연: 타입에 속하는 모든 객체들의 집합

자동차의 경우를 보자

- 심볼: 자동차
- 내연: 원동기를 동력원으로해서 사람이나 화물을 운반하는 주행 기계
- 외연: 세단, 트럭, SUV, 버스 ...

한 객체가 한 시점에 하나의 타입에만 속하는 것을 단일 분류라고 하고,
한 객체게 한 시점에 여러 타입에 속할 경우 다중분류라고 한다.

현실에서 객체는 동시에 여러 타입에 속할 수 있지만, 대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다.

대부분의 언어에서 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개 이상의 클래스의 인스턴스일 수 없다.
이는 다중상속과는 다르며 다중상속은 하나의 타입이 다수의 슈퍼타입을 가질 수 있도록 허용하는 것이다.

객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우 이를 동적 분류라 한다.
객체가 자신의 타입을 변경할 수 없는 경우 이를 정적 분류라고 한다.

대부분의 언어는 클래스로부터 인스턴스를 생성한 후 클래스를 변경할 수 있는 객체 타입변경을 제공하지 않는다.

다중 분류와 동적분류는 개념적인 관점에서 도메인을 분석하는데는 유용하지만 이를 구현으로 옮기기에는 쉽지않다.
단순함을 위해서 단일 분류와 정적 분류를 선택하는 것이 좋다.

클래스는 객체가 공유하는 본질적인 속성을 정의한다.
동일한 범주에 속하는 객체는 모두 동일한 속성을 가져야만 한다.

자바스크립트처럼 클래스가 존재하지 않는 프로토타입 기반의 언어는 분류와 인스턴스화를 프로토타입이라는 객체의 복사를 통해 달성한다.

### 일반화와 특수화

계층 구조는 세부적인 범주가 계층의 하위에 위치하고 일반적인 범주가 계층의 상위에 위치한다.
이때 계층의 상위에 위치한 범주를 계층의 하위에 위치한 범주의 일반화라고 하고,
계층의 하위에 위치한 범주는 계층의 상위에 위치한 범주의 특수화라고 한다.

객체지향의 세계에서 범주는 개념을 의미하고, 개념은 타입을 의미하므로 일반화와 특수화는 계층 구조안에 존재하는 타입간의 관계를 의미한다.

어떤 타입이 다른 타입보다 일반적이라면 이 타입을 supertype이라하고 다른 타입보다 더 특수하다면 subtype이라 한다.

일반화와 특수화의 계층구조에서 서브타입은 슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가적인 속성을 지닌다.

크레이그 라만은 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 '100% 규칙'과 'is-a 규칙'을 준수해야한다고 말했다.
규칙을 만족시키지 못할 경우 두 타입간의 일반화 관계는 성립하지 않는다.

- 100% 규칙: 슈퍼타입의 정의가 100% 서브타입에 적용되어야한다. 서브타입은 속성과 연관관계면에서 슈퍼타입과 100% 일치해야 한다
- is-a 규칙: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함되야한다. (`<subtype> is a <supertype>`)

프로그래밍 언어를 이용해 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스간의 상속을 이용하는 것이다.
그러나 모든 상속 관계가 일반화 관계인 것은 아니다.

일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응(conformance)해야 한다는 것이다.
순응에는 구조적인 순응(structural conformance)과 행위적인 순응(behavioral conformance)의 두 종류가 있다.

두 가지 모두 특정 기대 집합에 대해 서브타입의 슈퍼타입에 대한 대체 가능성을 의미한다.

구조적인 순응은 타입의 내연과 관련된 100% 규칙을 의미한다.
즉, 서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다.
따라서 서브타입이 슈퍼타입을 대체하더라도 구조에 관한 동일한 기대 집합을 만족시킬 수 있다.

> Person이 `name`이라는 속성을 가진다면 서브타입인 Employee 역시 `name` 속성을 가져야 한다

행위적인 순응은 타입의 행위에 관한 것이며, 서브타입은 슈퍼타입을 행위적으로 대체 가능해야한다.
행위적인 순응을 흔히 리스코프 치환 원칙(Liskov Substitution Principle)이라고 한다.

> Person의 `getAge()`라는 메시지에 대한 응답이 나이 반환이라면, 서브타입인 Employee의 `getAge()`라는 메시지에 대한 응답도 나이를 반환해야 함

상속의 또 다른 용도는 코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공하는 것이다.
어떠한 프로그래밍 언어도 상속이 대체 가능성을 만든다는 것을 보장하지 않는다.

클래스가 다른 클래스를 상속받았다는 사실만으로 두 클래스 간의 관계가 서브타이핑인지, 서브클래싱인지 여부를 결정할 수 없다.
서브타이핑의 전제조건은 대체 가능성이기때문에 서브타이핑인지 여부를 확인하려면 실제로 어떻게 사용되고 있는지를 확인해야 한다.

상속은 서브타이핑(subtyping)과 서브클래싱(subclassing)의 두 가지 용도로 사용될 수 있다.

- 서브타이핑: 서브클래스가 슈퍼클래스를 대체할 수 있는 경우
- 서브클래싱: 서브클래스가 슈퍼클래스를 대체할 수 없는 경우

흔히 서브타이핑을 인터페이스 상속이라고 하고, 서브클래싱을 구현 상속이라고 한다.

여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스간의 위임(delegation)을 사용하는 것이다.
어던 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로 위임한다.
위임은 계층 내의 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에 위임될 때까지 계속된다.

클래스가 없는 프로토타입 기반 언어에서 상속은 객체와 객체 간의 관계로 이루어진다.
프로토타입 기반 언어에서도 메시지는 클래스 기반의 객체지향 언어와 동일하게 위임 메커니즘에 의해 처리된다.

### 집합과 분해

안정적인 형태의 부분으로부터 전체를 구축하는 행위를 집합이라고 하고
집합과 반대로 전체를 부분으로 분할하는 행위를 분해라고 한다.

집합은 불필요한 세부사항을 추상화한다.
그러나 필요시점에서는 전체를 분해함으로써 그안에 포함된 부분들을 새로운 전체로 다룰 수 있다.

객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 합성 관계를 사용한다.

합성관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.

예를 들어 주문항목은 주문의 일부이므로 이 모델을 다루는 사람은 주문항목과 관련된 세부사항은 무시하고
주문과 상품만이 존재하는 것처럼 모델을 다룰 수 있다.
필요하다면 주문 내부로 들어가 주문항목과 관련된 세부사항을 확인할 수 있다.

상품과 주문 항목 사이에도 관계가 존재하지만 상품은 주문 항목의 일부가 아니다.
따라서 주문과 상품 간에는 단순한 물리적 통로가 존재하기만 하는데 이를 연관관계라 한다.

합성관계와 연관관계 사이의 차이가 명확한 것은 아니지만 일반적으로 생명주기의 차이가 있다.
위의 예에서 주문이 제거되면 주문 항목도 함께 제거되어야 하지만,
주문의 제거로 인해 주문항목이 제거되더라도 상품은 계속 판매된다.

관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 패키지(package) 또는 모듈(module)이라한다.

합성 관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부구조를 추상화하는 것처럼,
패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다.
