# Go Language 문자열 / 자료구조

## 문자열

문자열은 바이트가 연속적으로 나열되어 있는 것으로 Go 에서는 `string`이라는 자료형을 사용한다.
연속된 바이트를 나타내는 방식으로 `[]byte`가 있는데 이것과 달리 `string`은 읽기 전용이다.

### 유니코드 처리

Go 언어의 기본 인코딩은 UTF-8로 되어있다. 따라서 문자 처리에 1바이트 부터 최대 6바이트 까지 사용될 수 있다.

```go
for i, r := range "가나다" {
    fmt.Println(i, r)
}
fmt.Println(len("가나다"))

// output
// 0 44032
// 3 45208
// 6 45796
// 9
```

index는 글자당 3바이트씩이라 0, 3, 6이 출력되고 전체 글자는 9바이트 이므로 마지막에 9가 출력됨

### 테스트

테스트 파일은 테스트 대상 파일과 같은 이름 끝에 `_test`를 붙인다(`pikachu.go` -> `pikachu_test.go`)

그리고 난 뒤 콘솔에 테스트할 내용을 출력하고, 예상되는 결과를 `// Output:` 주석 다음줄 부터 주석으로 쓴다.

```go
package hangul

import "fmt"

func ExampleHasConsonantSuffix() {
    fmt.Println(HasConsonantSuffix("Go 언어"))
    fmt.Println(HasConsonantSuffix("그럼"))
    fmt.Println(HasConsonantSuffix("피카피카츄"))
    // Output:
    // false
    // true
    // false
}
```

### 바이트 단위 처리

문자열을 반복문에서 어떻게 사용하는지에 따라 유니코드 문자단위 혹은 바이트 단위로 동작한다.

문자열을 바이트 단위로 출력하려면 `fmt.Printf`를 사용할 수 있다.

`fmt.Printf("%x\n", "가나다")`
`fmt.Printf("% x\n", "가나다")`

바이트 단위로 스트링을 16진수로 출력하며 `% x`는 바이트 단위 사이 공백을 넣어 출력한다.

문자열은 읽기 전용이기 때문에 바이트를 조작하는 것은 불가능하다

```go
s := "가나다"
s[2]++ // 에러 발생
```

문자열을 바이트 단위의 슬라이스로 변환할 수 있다.
슬라이스는 배열을 유연하게 만든 자료구조로 자바의 ArrayList, C++의 vector와 비슷하다.

`rune`이 `int32`의 별칭이듯 `byte`는 `uint8`의 별칭이다.

문자열을 byte 슬라이스로, byte 슬라이스를 문자열로 형변환 할 수 있다.

```go
func Example_modifyBytes() {
    b := []byte("가나다")
    b[2]++
    fmt.Println(string(b))
    // Output:
    // 각나다
}
```

어떤 문자열이 들어있는지가 중요하다면 string, 실제 바이트 표현이 중요하다면 []byte를 이용하는 것이 좋다.

### 문자열 잇기

문자열은 읽기 전용이므로 문자열을 이어 붙이기 위해서는 이어붙이 문자열을 새로 만들게 된다

문자열을 이어 붙이려면 `+` 연산을 이용하면 된다.

Go의 문자열은 사실상 문자열에 대한 포인터와 비슷하기 때문에 이어붙이면 다음같은 결과가 나온다

```go
func Example_strCat() {
    s := "abc"
    ps := &s
    s += "def"
    fmt.Println(s)
    fmt.Println(*ps)
    // Output:
    // abcdef
    // abcdef
}
```

`ps`는 `s`의 포인터 형식인 `*string`형인데, `s`에 concatenation을 적용하니 `ps`의 출력값도 변화한다.

### 문자열을 숫자로

문자열 형태로 된 숫자 - "5" - 를 정수형으로 변경하기 위해 `int(5)`를 이용한다면,
해당 문자의 유니코드 포인트 숫자로 변환되므로 다른 방법을 이용해야 한다.

`strconv` 패키지의 함수를 이용할 수 있다

- `strconv.Atoi()`: 문자열을 정수로
- `strconv.ParseInt()`: 64비트 정수나 10진수가 아닌 수를 변환 할 수 있다
- `strconv.ParseFloat()`: 실수형 변환
- `strconv.Itoa`: 숫자를 문자열로 변환
- `strconv.FormatInt()`

## 배열과 슬라이스

### 배열

배열은 연속된 메모리 공간을 순차적으로 이용하는 자료구조이다.

```go
func Example_array() {
    fruits := [3]string{"사과", "바나나", "토마토"}
    // fruits := [...]string{"사과", "바나나", "토마토"} // ... 키워드로 컴파일러가 배열 크기 처리함
    for _, fruit := range fruits {
        fmt.Printf("%s는 맛있다.\n", fruit)
    }
    // Output:
    // 사과는 맛있다.
    // 바나나는 맛있다.
    // 토마토는 맛있다.
}
```

### 슬라이스

배열은 유연한 구조의 슬라이스가 있어 자주 쓰이지 않는다.
배열은 크기가 자료형에 고정되어 있지만, 슬라이스는 길이가 변할 수 있는 구조이다.

`var fruits []string`

위 처럼 빈 문자열 슬라이스를 생성할 수 있다.
빈 문자열 슬라이스는 `nil` 값이 들어간다. (자바의 `null`과 비슷한 개념)
빈 슬라이스를 생성하면 해당 자료형의 기본값이 들어간다 (정수의 경우 0)

만약 빈 값을 n개 갖고 있는 슬라이스를 만드려면 다음과 같이 하면 된다.

`fruits := make([]string, n)`

배열처럼 i번째에 직접 접근하여 값을 변경할 수 있다.

슬라이스는 원하는 범위로 자를 수 있다.

```go
func Example_slicing() {
    nums := []int{1, 2, 3, 4, 5}
    fmt.Println(nums)
    fmt.Println(nums[1:3])
    fmt.Println(nums[2:])
    fmt.Println(nums[:3])
    // Output:
    // [1 2 3 4 5]
    // [2 3]
    // [3 4 5]
    // [1 2 3]
}
```

파이썬의 슬라이싱과 유사한데 파이썬과 다르게 음수를 사용할 수는 없다.

### 슬라이스 덧붙이기

`fruits = append(fruits, "포도")`

`append`는 가변인자를 받으므로 여러개를 덧붙일 수도 있다.

`fruits = append(fruits, "포도", "딸기")`

두 슬라이스를 이어 붙이려면 슬라이스에 들어있는 각각의 값을 늘어놓으면 된다.

```go
fun Example_append() {
    f1 := []string{"사과", "바나나", "토마토"}
    f2 := []string{"포도", "딸기"}
    f3 := append(f1, f2...) // 이어붙이기
    f4 := append(f1[:2], f2...) // f1에서 토마토 제외하고 이어붙이기
}
```

### 슬라이스 용량

길이를 5로 알고 있는 상태에서 초기화 - `make([]int, 5)`, `[]int{0, 0, 0, 0, 0}` - 한 경우
길이와 용량도 5로 맞춰지게 된다.

이런경우 슬라이드 덧붙이기를 하면 다른 곳에 슬라이스가 할당되며 기존 값은 복사된다.

길이를 알아낼 때 `len(x)`를 이용하듯 용량을 알아낼 때 `cap(x)`를 이용할 수 있다.

슬라이스를 하는 경우에는 앞에서 잘라내면 길이와 용량이 함께 감소하고,
뒤에서 잘라내면 용량은 그대로 길이만 감소한다.
반대로 뒤에서 잘라낸 슬라이스를 확장하면 잘라낸 부분이 살아난다.

이는 슬라이스는 원본과 동일한 메모리를 보고 있는 것이기 때문이다.
만약 메모리에서 직접 값을 수정하면 다른 슬라이스의 값도 모두 변하게 된다.

슬라이스를 생성할 때 길이와 용량을 별도로 설정하여 생성할 수도 있다.
이는 빈 슬라이스를 생성할 때 추가될 개수를 예측하여 빈 공간을 미리 예약해두고 싶을 때 사용할 수 있다.

`nums := make([]int, 3, 5)`: 길이는 3, 용량은 5인 슬라이스

### 슬라이스 내부구현

슬라이스는 배열 가리키고 있는 구조체라고 볼 수 있다.

슬라이스는 3개의 필드로 이루어져 있다: **시작 주소, 길이, 용량**

복사가 일어나서 이동이 발생하면 크기가 다른 배열을 생성해야 하고 슬라이스는 다른 배열을 바라보게 된다.

`nums = append(nums, 10)`의 경우 추가될 인자 `10`이 앞의 인자 `nums` 슬라이스를 초과하는지 우선 조사하게 된다.

1. 크기초과X: 길이가 증가한 슬라이스를 반환받아 재할당
2. 크기초과O: 복사/확장한 배열을 가리키는 슬라이스를 반환받아 재할당

만약 반환된 슬라이스를 재할당하지 않으면, 메모리상에 데이터는 `append`되었으나 슬라이스는 그 데이터를 가리킬 수 없게 된다.

### 슬라이스 복사

```go
func Example_sliceCopy() {
    src := []int{30, 20, 50, 10, 40}
    dest := make([]int, len(src))
    for i := range src {
        dest[i] = src[i]
    }
    fmt.Println(dest)
    // Output: [30 20 50 10 40]
}
```

`copy`라는 함수가 복사를 지원함: `copy(dest, src)`

`copy`함수는 몇 개가 복사되었는지 반환함

```go
if n := copy(dest, src); n != len(src) {
    fmt.Println("복사가 덜 됐습니다")
}
```

`dest`의 크기가 부족한 경우 복사가 모두 이루어지지 않게 된다.
따라서 `copy`로 슬라이스 전체를 복사하려면 다음과 같은 코드가 필요하다.

```go
dest := make([]int, len(src))
copy(dest, src)
```

`copy`는 서로 공간이 겹치는 두 슬라이스를 복사할 때도 사용될 수 있다.

`append` 함수를 이용해서도 복사된 슬라이스를 얻을 수 있다.

```go
dest := append([]int(nil), src...)
```

### 슬라이스 삽입 및 삭제

Go 언어에서는 슬라이스 삽입 및 삭제 메서드를 제공하지 않는다.
따라서 필요하다면 직접구현하거나 구현되어 있는 라이브러리를 사용해야 한다.

#### 슬라이스 삽입

a 슬라이스의 i번째 원소로 x를 삽입하려는 경우를 살펴보자

```go
if i < len(a) {
    a = append(a[:i+1], a[i:]...)
    a[i] = x
} else {
    a = append(a, x)
}
```

`i == len(a)`이면 맨 오른쪽에 삽입하려는 경우인데 덧붙이려는 두 번째 값 `a[i+1]` 부터 슬라이스 범위를 초과한다.
따라서 맨 오른쪽에 삽입하는 조건을 분리해야 한다.

다른 방법도 가능하다

```go
a = append(a, x)
copy(a[i+1], a[i:])
a[i] = x
```

기존 슬라이스 끝에 추가할 값을 붙인 뒤, 공간 하나를 남긴채 i번째 뒤의 내용을 덧붙인 슬라이스를 생성한다.
생성한 슬라이스에 확보된 i번째 위치에 마지막 x의 값을 할당한다.

위의 패턴은 여러개의 값에도 적용가능하다.

```go
x := []int{1, 2, 3}
a = append(a, x...)
copy(a[i+len(x):], a[i:])
copy(a[i:], x)
```

#### 슬라이스 삭제

```go
a = append(a[:i], a[i+1:])
```

연속된 k개를 지우려는 경우

```go
a = append(a[:i], a[i+k:])
```

삭제하면서 순서변경이 일어나도 괜찮다면: O(n)의 사간복잡도에서 O(1)의 시간복잡도가 됨

```go
a[i] = a[len(a)-1]
a = a[:len(a)-1]
```

연속된 k개를 삭제하는 경우: 이경우에는 시간복잡도가 O(k)가 됨

```go
start := len(a) - k
if i+k > start {
    start = i+k
}
copy(a[i:i+k], a[start:])
a = a[:len(a)-k]
```

삭제시 중요한점이 있다.
만약 삭제되는 슬라이스 내부에 포인터가 있는경우, 이것이 뒤의 공간에 남아있으면 GC가 일어나지 않아 메모리 누수가 일어난다.

위의 경우 마지막에 슬라이스를 슬라이싱 한 것이기 때문에 슬라이스의 크기는 변하지 않는다.
따라서 해당영역의 메모리를 반환하지 않고 사용하는데, 여기에 포인터가 있다면 포인터가 가리키는 객체들을 GC 할 수 없다.

이런 경우 슬라이스 뒤의 공간에 있는 포인터를 `nil`로 삭제해주어야 한다.

슬라이스가 이용하는 배열이 직접 포인터를 갖고있는 것이 아니라 구조체 배열에서 구조체들이 포인터를 갖고있는 경우에도 동일한 문제가 발생한다.
이럴때는 구조체 내부의 포인터를 `nil`로 초기화 시켜주거나, 해당 구조체를 빈 구조체로 덮어써야 한다.

순서를 유지하면서 i 번째를 삭제할 때 포인터 슬라이스의 경우,
한 칸씩 당겨서 복사하고 마지막 포인터를 지운 뒤 슬라이싱 하면 된다.

```go
copy(a[i:], a[i+1:])
a[len(a)-1] = nil // 마지막 포인터 삭제 생략시 메모리 누수 발생가능
a = a[:len(a)-1]
```

연속된 k개를 지우는 경우 마지막 k개를 지우고 슬라이싱 한다.

```go
copy(a[i:], a[i+k:])
for i := 0; i < k; i++ {
    a[len(a)-1-i] = nil
}
a = a[:len(a)-k]
```

포인터를 포함한 구조체의 경우 `nil` 대신 `T{}`를 넣어주면 된다.

### 스택

Go 표준 라이브러리에 스택 자료구조가 있지는 않다.
Slice로 스택을 표현하기 위해 append로 집어넣고, 마지막 요소를 제거하는 것으로 대체할 수 있다.

```go
// TODO: 스택 구현
```

## 맵

Go 언어에서 map은 해시테이블로 구현된다. 해시맵에는 순서가 없다.

맵 생성은 다음과 같은 방법으로 할 수 있다.

```go
m := make(map[keyType]valueType)
// 또는
m := map[keyType]valueType{}
```

맵에서 자료를 읽을 때는 두 가지 방법이 가능하다. 만약 키가 없으면 자료형의 기본값을 반환한다.

```go
value := m[key]
value, ok := m[key] // ok는 키 존재여부를 bool형으로 받는다
```

맵에 값을 쓸 때는 다음과 같이 쓸 수 있다. 이미 키가 있는 경우 기존값을 변경한다.

```go
m[key] = value
```

### 맵 사용하기
