# GIT for Teams

## 커밋 메시지

<https://www.conventionalcommits.org/ko/>

```text
add: 게시물 조회기능
───  ─────────────
│     │
│     └─> 작업내용 요약
│
└───────> 커밋 메시지 타입
```

- `add`: 코드에 새로운 부분(기능적으로)이 추가됨
- `update`: 새로 추가된 부분이 아니면서 issue(`fix || resolve`) 없이 변경된 코드
- `fix`: 오류나 이상작동을 수정함
- `resolve`: issue상의 요구 사항이 반영됨
- `refactor`: 코드 리팩토링
- `format`: 코드 포맷 수정
- `test`: 테스트 관련 코드 추가/수정
- `docs`: 문서관련 작업
- `chore`: production code에 영향을 미치지 않는 작업 (빌드 설정, 의존성 관리...)
- `bump`: version to x.y.z

## 브랜치 전략

모든 Git 저장소에는 커밋 pool이 있다. 이 커밋들은 자신의 메타데이터를 통해 서로 연결돼있다.
모든 커밋은 자신의 부모에 대한 참조를 갖는다. 병합 커밋의 경우, 하나 이상의 부모 커밋이 참조될 수 있다.

Git의 브랜치는 특정 커밋에 대한 이름이 있는 포인터라고 할 수 있다.
브랜치를 살펴본다는 것은, 포인터가 가리키는 커밋 객체에 담긴 데이터를 복사한다는 것을 의미한다.
일단 데이터가 작업 폴더로 복사되면 원하는 대로 고칠 수 있다.

커밋 객체는 처음 생성했을 때 로컬에 속하고, 오직 생성한 사람의 것이다.

## 규약

### 메인라인 브랜치 개발

개발자들은 지속해서 하나의 중앙 브랜치에 작업을 커밋한다.
중앙 브랜치는 항상 배포 준비 상태로 유지한다. 다른말로 하면 프로젝트의 메인 브랜치는 오직 이미 검토완료된 작업만 담아야 하고 오류가 없어야 한다.

보통 자동 빌드 과정을 사용하는 팀들이 하나의 작업 브랜치로 일하는 경우가 많다.

작업을 하다보면 로컬 작업코드와 완성품 코드를 구분할 필요가 생긴다.
이 점 때문에 완전한 연속배포 전략을 취하지 않고, 여러개의 브랜치와 정기배포 전략을 사용한다.

### 기능별 브랜치 배포

기능별 브랜치 배포 전략에서 새로운 모든 작업은 기능 브랜치에서 이뤄진다.
기능 브랜치는 하나의 온전한 아이디어를 담을 만큼으로 크기를 한정한다.

기능 브랜치는 통합 브랜치를 통해 다른 개발자의 작업을 가져와 최신 코드상태를 유지한다.

기능브랜치와 하나의 통합브랜치(릴리즈 브랜치)를 추가하면 배포 준비가 완료된 코드를 가질 수 있다.

마스터에 병합된 브랜치는 삭제해야 한다.

### 상태 브랜칭

- 브랜치 이름은 구체적으로 작업 상황을 설명하고 당면 작업과 관련이 있어야한다.
- 개별 브랜치의 목적을 추측할 필요가 없어 사람들이 자신의 작업을 병합할 올바른 브랜치를 찾기 쉽다.

- 이름이 아무리 구체적이라 해도 안내없이 어떤 브랜치를 사용할지 분명한 것은 아니다
- 브랜치 이름이 해당팀의 상황을 구체적으로 설명하기 때문에 여러 프로젝트간 일관성을 유지하기 어렵다.

### 정기배포

완전한 테스트 자동화 프로그램들이 없고 정기적으로 배포해야 하는 상황이라면, 정기 배포 전략이 가장 적절하다.

처음 프로젝트는 하나의 브랜치 develop을 가진다. 이 브랜치로부터 브랜치를 생성하여 기능을 추가한다.
기능은 버그수정, 리팩토링, 완전히 새로운기능일 수도 있다.

티켓을 통해 작업할 기능을 설명하고 해당 브랜치의 이름은 티켓의 이름에서 따온다.
`[티켓id]-[제목]` 또는 `[tag]-[제목](#티켓id)` 형식으로 사용할 수 있다.

기능추가가 목표지점에 이르렀다면 기능을 동결한다. develop 브랜치로부터 새로운 브랜치를 생성하고 해당 브랜치에는 오직 버그수정 커밋만 허용된다.
release 브랜치에 커밋된 버그수정은 다시 develop 브랜치에 백포트 해야한다.
품질 관리기간이 길어질수록 develop 브랜치와 release 브랜치 양쪽에서 작업하게 될 확률이 높아질 것이다.

테스트를 진행한 후 배포준비가 끝났다고 판단되면 새로운 브랜치 main에 커밋되고, 당시 소프트웨어 버전을 태그로 단다.
만약 main에서 버그가 발견되어 수정이 필요하다면 hotfix 브랜치를 만들어 main과 develop에 동시 반영한다.

## 브랜치 업데이트 하기

브랜치를 업데이트할 때는 병합과 리베이스 중 하나를 선택할 수 있다.

원격참조를 통해 추적 브랜치를 업데이트 하는 과정은 일반적으로 pull 명령어를 사용해 실행한다.
단, pull은 두 가지 별개의 과정, fetch와 merge 또는 fetch와 rebase의 조합이다.

기본적으로 pull 명령어는 병합 전략을 사용해 로컬 브랜치를 업데이트 한다.
그러나 `-rebase`라는 매개변수를 사용하면 리베이스전략을 사용해 로컬 브랜치를 업데이트 할 수 있다.

> 리베이스를 사용하는 방법에는 두가지가 있다. 첫째, 병합 방법의 대안으로 새로운 작업을 관련 브랜치에 통합하는것. 둘째, 기존의 브랜치에 개별 커밋을 추가, 변경, 삭제하는 식으로 히스토리를 고쳐 해당 히스토리를 간결하게 만드는 것.

두 개의 브랜치가 FF-Merge나 Rebase를 사용하여 병합하면 결과 그래프(history)는 사실상 같다.
하지만 업데이트를 위해 병합하면 연결이 양방향이 되면서 히스토리 그래프는 상당히 달라질 수 있다.

이런 동기화 문제 때문에 일반적으로 프로젝트에 다시 합칠 작업을 할 때는 추적 브랜치에서 작업하지 않는다.
브랜치 전략과 상관없이 추적 브랜치는 보통 장기적 브랜치(main / release)에 연결하고 작업 브랜치는 기능이나 티켓 또는 핫픽스 브랜치가 된다.

리베이스를 통한 브랜치 업데이트 작업을 하면 히스토리를 단순화시켜 읽기 쉽게 해준다.
그러나 여기에는 대가가 따른다. 해당 브랜치 사본에 개발자가 생성한 커밋 객체가 포함된 경우 특히 그렇다.
자신만의 커밋을 가진 브랜치를 리베이스 하려면 해당 커밋을 새로운 브랜치 팁에 다시 재생해야한다.
각각의 커밋은 새로운 부모를 갖게 되면서 완전히 새로운 확인자를 할당받게 된다.
특히 새로운 부모를 할당받는 커밋이 이전에 원격 저장소를 통해 공유된 적이 있다면 혼란을 초래한다.
새로운 확인자 뿐만아니라 커밋을 재생할 때마다 충돌 해결에 시간이 소요된다.

## GitFlow

- <https://docs.github.com/ko/get-started/quickstart/github-flow>
- <https://docs.gitlab.com/ee/topics/gitlab_flow.html#production-branch-with-gitlab-flow>
- <https://medium.com/burdaforward/state-of-ci-cd-and-the-dreaded-git-flow-fce92d04fb07>
- [Git Flow 가 CI/CD 와 어울리지 않는 이유 by David Farley](https://creampuffy.tistory.com/183)
- [Git Flow에서 트렁크 기반 개발으로 나아가기 - 맘시터 기술블로그](https://tech.mfort.co.kr/blog/2022-08-05-trunk-based-development/)
- [더 나은 Git 워크플로우를 향해서](https://black7375.tistory.com/92)

## Sapling

Meta에서 사용하는 Git 호환 버전 관리

- [Sapling - 사용자 친화적이고 스케일러블한 Git 호환 버전 관리](https://news.hada.io/topic?id=7887)
- <https://sapling-scm.com/>

### Git Branchless

Meta의 Sapling과 유사한 Git 워크플로우 지원도구

- [Git-Branchless - 브랜치를 사용하지 않는 Git 워크플로우 지원 도구 모음](https://news.hada.io/topic?id=6970)
- <https://github.com/arxanas/git-branchless>
